diff --git a/node_modules/react-native-graph/lib/module/AnimatedLineGraph.js b/node_modules/react-native-graph/lib/module/AnimatedLineGraph.js
index 88d58ed..e9c2ec3 100644
--- a/node_modules/react-native-graph/lib/module/AnimatedLineGraph.js
+++ b/node_modules/react-native-graph/lib/module/AnimatedLineGraph.js
@@ -235,6 +235,7 @@ export function AnimatedLineGraph(_ref) {
 
     if (isActive.value) pathEnd.current = fingerX / width;
     const fingerXInRange = Math.max(fingerX - horizontalPadding, 0);
+
     const index = Math.round(fingerXInRange / getXInRange(drawingWidth, pointsInRange[pointsInRange.length - 1].date, pathRange.x) * (pointsInRange.length - 1));
     const pointIndex = Math.min(Math.max(index, 0), pointsInRange.length - 1);
 
diff --git a/node_modules/react-native-graph/lib/typescript/LineGraphProps.d.ts b/node_modules/react-native-graph/lib/typescript/LineGraphProps.d.ts
index 5a8490e..6afd3f6 100644
--- a/node_modules/react-native-graph/lib/typescript/LineGraphProps.d.ts
+++ b/node_modules/react-native-graph/lib/typescript/LineGraphProps.d.ts
@@ -44,8 +44,11 @@ interface BaseLineGraphProps extends ViewProps {
      */
     enableFadeInMask?: boolean;
 }
-export declare type StaticLineGraphProps = BaseLineGraphProps & {};
+export declare type StaticLineGraphProps = BaseLineGraphProps & {
+    useSVG?: boolean;
+};
 export declare type AnimatedLineGraphProps = BaseLineGraphProps & {
+    shadowColor?: string;
     /**
      * Whether to enable Graph scrubbing/pan gesture.
      */
diff --git a/node_modules/react-native-graph/src/AnimatedLineGraph.tsx b/node_modules/react-native-graph/src/AnimatedLineGraph.tsx
index 7bba35a..ecbb5fe 100644
--- a/node_modules/react-native-graph/src/AnimatedLineGraph.tsx
+++ b/node_modules/react-native-graph/src/AnimatedLineGraph.tsx
@@ -12,9 +12,9 @@ import {
   vec,
   Group,
   PathCommand,
-  useSharedValueEffect,
-  mix,
-  Circle,
+  // useSharedValueEffect,
+  // mix,
+  // Circle,
   Shadow,
 } from '@shopify/react-native-skia'
 import type { AnimatedLineGraphProps } from './LineGraphProps'
@@ -31,29 +31,30 @@ import Reanimated, {
   runOnJS,
   useAnimatedReaction,
   useSharedValue,
-  useDerivedValue,
-  cancelAnimation,
-  withRepeat,
-  withSequence,
-  withTiming,
-  withDelay,
+  // useDerivedValue,
+  // cancelAnimation,
+  // withRepeat,
+  // withSequence,
+  // withTiming,
+  // withDelay,
 } from 'react-native-reanimated'
 import { getSixDigitHex } from './utils/getSixDigitHex'
 import { GestureDetector } from 'react-native-gesture-handler'
 import { usePanGesture } from './hooks/usePanGesture'
-import { getYForX } from './GetYForX'
-import { hexToRgba } from './utils/hexToRgba'
+// import { getYForX } from './GetYForX'
+// import { hexToRgba } from './utils/hexToRgba'
 
 const INDICATOR_RADIUS = 7
 const INDICATOR_BORDER_MULTIPLIER = 1.3
-const INDICATOR_PULSE_BLUR_RADIUS_SMALL =
-  INDICATOR_RADIUS * INDICATOR_BORDER_MULTIPLIER
-const INDICATOR_PULSE_BLUR_RADIUS_BIG =
-  INDICATOR_RADIUS * INDICATOR_BORDER_MULTIPLIER + 20
+// const INDICATOR_PULSE_BLUR_RADIUS_SMALL =
+//   INDICATOR_RADIUS * INDICATOR_BORDER_MULTIPLIER
+// const INDICATOR_PULSE_BLUR_RADIUS_BIG =
+//   INDICATOR_RADIUS * INDICATOR_BORDER_MULTIPLIER + 20
 
 export function AnimatedLineGraph({
   points: allPoints,
   color,
+  shadowColor,
   gradientFillColors,
   lineThickness = 3,
   range,
@@ -85,19 +86,21 @@ export function AnimatedLineGraph({
   const circleX = useValue(0)
   const circleY = useValue(0)
   const pathEnd = useValue(0)
-  const indicatorRadius = useValue(enableIndicator ? INDICATOR_RADIUS : 0)
-  const indicatorBorderRadius = useComputedValue(
-    () => indicatorRadius.current * INDICATOR_BORDER_MULTIPLIER,
-    [indicatorRadius]
-  )
-
-  const pulseTrigger = useDerivedValue(() => {
-    'worklet'
-    return isActive.value ? 1 : 0
-  }, [])
-  const indicatorPulseAnimation = useSharedValue(0)
-  const indicatorPulseRadius = useValue(INDICATOR_PULSE_BLUR_RADIUS_SMALL)
-  const indicatorPulseOpacity = useValue(1)
+  // const indicatorRadius = useValue(enableIndicator ? INDICATOR_RADIUS : 0)
+  // const indicatorBorderRadius = useComputedValue(
+  //   () => indicatorRadius.current * INDICATOR_BORDER_MULTIPLIER,
+  //   [indicatorRadius]
+  // )
+
+  // const pulseTrigger = useDerivedValue(() => {
+  //   'worklet'
+  //   return isActive.value ? 1 : 0
+  // }, [])
+  // const indicatorPulseAnimation = useSharedValue(0)
+  // const indicatorPulseRadius = useSharedValue(INDICATOR_PULSE_BLUR_RADIUS_SMALL)
+  // const indicatorPulseRadius = useValue(INDICATOR_PULSE_BLUR_RADIUS_SMALL)
+  // const indicatorPulseOpacity = useSharedValue(1)
+  // const indicatorPulseOpacity = useValue(1)
 
   const positions = useComputedValue(
     () => [
@@ -150,29 +153,29 @@ export function AnimatedLineGraph({
     [horizontalPadding, width]
   )
 
-  const lineWidth = useMemo(() => {
-    const lastPoint = pointsInRange[pointsInRange.length - 1]
-
-    if (lastPoint == null) return drawingWidth
-
-    return Math.max(getXInRange(drawingWidth, lastPoint.date, pathRange.x), 0)
-  }, [drawingWidth, pathRange.x, pointsInRange])
-
-  const indicatorX = useMemo(
-    () =>
-      commandsChanged >= 0
-        ? Math.floor(lineWidth) + horizontalPadding
-        : undefined,
-    [commandsChanged, horizontalPadding, lineWidth]
-  )
-  const indicatorY = useMemo(
-    () =>
-      commandsChanged >= 0 && indicatorX != null
-        ? getYForX(commands.current, indicatorX)
-        : undefined,
-    [commandsChanged, indicatorX]
-  )
-  const indicatorPulseColor = useMemo(() => hexToRgba(color, 0.4), [color])
+  // const lineWidth = useMemo(() => {
+  //   const lastPoint = pointsInRange[pointsInRange.length - 1]
+
+  //   if (lastPoint == null) return drawingWidth
+
+  //   return Math.max(getXInRange(drawingWidth, lastPoint.date, pathRange.x), 0)
+  // }, [drawingWidth, pathRange.x, pointsInRange])
+
+  // const indicatorX = useMemo(
+  //   () =>
+  //     commandsChanged >= 0
+  //       ? Math.floor(lineWidth) + horizontalPadding
+  //       : undefined,
+  //   [commandsChanged, horizontalPadding, lineWidth]
+  // )
+  // const indicatorY = useMemo(
+  //   () =>
+  //     commandsChanged >= 0 && indicatorX != null
+  //       ? getYForX(commands.current, indicatorX)
+  //       : undefined,
+  //   [commandsChanged, indicatorX]
+  // )
+  // const indicatorPulseColor = useMemo(() => hexToRgba(color, 0.4), [color])
 
   const shouldFillGradient = gradientFillColors != null
 
@@ -318,35 +321,38 @@ export function AnimatedLineGraph({
     [interpolateProgress]
   )
 
-  const stopPulsating = useCallback(() => {
-    cancelAnimation(indicatorPulseAnimation)
-    indicatorPulseAnimation.value = 0
-  }, [indicatorPulseAnimation])
-
-  const startPulsating = useCallback(() => {
-    indicatorPulseAnimation.value = withRepeat(
-      withDelay(
-        1000,
-        withSequence(
-          withTiming(1, { duration: 1100 }),
-          withTiming(0, { duration: 0 }), // revert to 0
-          withTiming(0, { duration: 1200 }), // delay between pulses
-          withTiming(1, { duration: 1100 }),
-          withTiming(1, { duration: 2000 }) // delay after both pulses
-        )
-      ),
-      -1
-    )
-  }, [indicatorPulseAnimation])
+  // const stopPulsating = useCallback(() => {
+  //   cancelAnimation(indicatorPulseAnimation)
+  //   indicatorPulseAnimation.value = 0
+  // }, [indicatorPulseAnimation])
+
+  // const startPulsating = useCallback(() => {
+  //   indicatorPulseAnimation.value = withRepeat(
+  //     withDelay(
+  //       1000,
+  //       withSequence(
+  //         withTiming(1, { duration: 1100 }),
+  //         withTiming(0, { duration: 0 }), // revert to 0
+  //         withTiming(0, { duration: 1200 }), // delay between pulses
+  //         withTiming(1, { duration: 1100 }),
+  //         withTiming(1, { duration: 2000 }) // delay after both pulses
+  //       )
+  //     ),
+  //     -1
+  //   )
+  // }, [indicatorPulseAnimation])
 
   const setFingerX = useCallback(
     (fingerX: number) => {
-      const y = getYForX(commands.current, fingerX)
 
-      if (y != null) {
+      if (!pointsInRange?.[pointsInRange.length - 1]?.date) return 
+
+      // const y = getYForX(commands.current, fingerX)
+
+      //if (y != null) {
         circleX.current = fingerX
-        circleY.current = y
-      }
+        //circleY.current = y
+      //}
 
       if (isActive.value) pathEnd.current = fingerX / width
 
@@ -356,7 +362,7 @@ export function AnimatedLineGraph({
         (fingerXInRange /
           getXInRange(
             drawingWidth,
-            pointsInRange[pointsInRange.length - 1]!.date,
+            pointsInRange[pointsInRange.length - 1].date,
             pathRange.x
           )) *
           (pointsInRange.length - 1)
@@ -374,7 +380,7 @@ export function AnimatedLineGraph({
     },
     [
       circleX,
-      circleY,
+      // circleY,
       drawingWidth,
       horizontalPadding,
       isActive.value,
@@ -388,30 +394,30 @@ export function AnimatedLineGraph({
 
   const setIsActive = useCallback(
     (active: boolean) => {
-      runSpring(indicatorRadius, !active ? INDICATOR_RADIUS : 0, {
-        mass: 1,
-        stiffness: 1000,
-        damping: 50,
-        velocity: 0,
-      })
+      // runSpring(indicatorRadius, !active ? INDICATOR_RADIUS : 0, {
+      //   mass: 1,
+      //   stiffness: 1000,
+      //   damping: 50,
+      //   velocity: 0,
+      // })
 
       if (active) {
         onGestureStart?.()
-        stopPulsating()
+        //stopPulsating()
       } else {
         onGestureEnd?.()
         pointSelectedIndex.current = undefined
         pathEnd.current = 1
-        startPulsating()
+        //startPulsating()
       }
     },
     [
-      indicatorRadius,
+      //indicatorRadius,
       onGestureEnd,
       onGestureStart,
       pathEnd,
-      startPulsating,
-      stopPulsating,
+      // startPulsating,
+      // stopPulsating,
     ]
   )
 
@@ -438,29 +444,29 @@ export function AnimatedLineGraph({
       pathEnd.current = 1
   }, [commands, pathEnd, pointsInRange.length])
 
-  useEffect(() => {
-    if (indicatorPulsating) {
-      startPulsating()
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [indicatorPulsating])
-
-  useSharedValueEffect(
-    () => {
-      if (pulseTrigger.value === 0) {
-        indicatorPulseRadius.current = mix(
-          indicatorPulseAnimation.value,
-          INDICATOR_PULSE_BLUR_RADIUS_SMALL,
-          INDICATOR_PULSE_BLUR_RADIUS_BIG
-        )
-        indicatorPulseOpacity.current = mix(indicatorPulseAnimation.value, 1, 0)
-      } else {
-        indicatorPulseRadius.current = 0
-      }
-    },
-    indicatorPulseAnimation,
-    pulseTrigger
-  )
+  // useEffect(() => {
+  //   if (indicatorPulsating) {
+  //     startPulsating()
+  //   }
+  //   // eslint-disable-next-line react-hooks/exhaustive-deps
+  // }, [indicatorPulsating])
+
+  // useSharedValueEffect(
+  //   () => {
+  //     if (pulseTrigger.value === 0) {
+  //       indicatorPulseRadius.current = mix(
+  //         indicatorPulseAnimation.value,
+  //         INDICATOR_PULSE_BLUR_RADIUS_SMALL,
+  //         INDICATOR_PULSE_BLUR_RADIUS_BIG
+  //       )
+  //       indicatorPulseOpacity.current = mix(indicatorPulseAnimation.value, 1, 0)
+  //     } else {
+  //       indicatorPulseRadius.current = 0
+  //     }
+  //   },
+  //   indicatorPulseAnimation,
+  //   pulseTrigger
+  // )
 
   const axisLabelContainerStyle = {
     paddingTop: TopAxisLabel != null ? 20 : 0,
@@ -513,6 +519,7 @@ export function AnimatedLineGraph({
                     colors={gradientColors}
                     positions={positions}
                   />
+                     {shadowColor && <Shadow dx={-1} dy={-1} color={shadowColor}  blur={3} />}
                 </Path>
 
                 {shouldFillGradient && (
@@ -539,7 +546,7 @@ export function AnimatedLineGraph({
                 />
               )}
 
-              {enableIndicator && (
+              {/* {enableIndicator && (
                 <Group>
                   {indicatorPulsating && (
                     <Circle
@@ -567,7 +574,7 @@ export function AnimatedLineGraph({
                     color={color}
                   />
                 </Group>
-              )}
+              )} */}
             </Canvas>
           </View>
 
diff --git a/node_modules/react-native-graph/src/CreateGraphPath.ts b/node_modules/react-native-graph/src/CreateGraphPath.ts
index 67e9a2e..e4a9c39 100644
--- a/node_modules/react-native-graph/src/CreateGraphPath.ts
+++ b/node_modules/react-native-graph/src/CreateGraphPath.ts
@@ -193,7 +193,7 @@ function createGraphPathBase({
           return pixel + additionalPixel === exactPointX
         })
 
-      if (!isExactPointInsidePixelRatio) continue
+      // if (!isExactPointInsidePixelRatio) continue
     }
 
     const value = graphData[index]!.value
diff --git a/node_modules/react-native-graph/src/LineGraphProps.ts b/node_modules/react-native-graph/src/LineGraphProps.ts
index f3f27d7..a2ca264 100644
--- a/node_modules/react-native-graph/src/LineGraphProps.ts
+++ b/node_modules/react-native-graph/src/LineGraphProps.ts
@@ -51,8 +51,10 @@ interface BaseLineGraphProps extends ViewProps {
 
 export type StaticLineGraphProps = BaseLineGraphProps & {
   /* any static-only line graph props? */
+  useSVG?: boolean
 }
 export type AnimatedLineGraphProps = BaseLineGraphProps & {
+  shadowColor?: string
   /**
    * Whether to enable Graph scrubbing/pan gesture.
    */
diff --git a/node_modules/react-native-graph/src/StaticLineGraph.tsx b/node_modules/react-native-graph/src/StaticLineGraph.tsx
index cd5f0aa..edfc2e8 100644
--- a/node_modules/react-native-graph/src/StaticLineGraph.tsx
+++ b/node_modules/react-native-graph/src/StaticLineGraph.tsx
@@ -1,9 +1,11 @@
 import { Canvas, LinearGradient, Path, vec } from '@shopify/react-native-skia'
 import { getSixDigitHex } from './utils/getSixDigitHex'
 import React, { useCallback, useMemo, useState } from 'react'
+import { Svg, Path as SVGPath, LinearGradient as SVGLinearGradient, Defs, Stop } from 'react-native-svg'
 import { View, StyleSheet, LayoutChangeEvent } from 'react-native'
 import {
   createGraphPath,
+  createGraphPathWithGradient,
   getGraphPathRange,
   getPointsInRange,
   GraphPathRange,
@@ -17,11 +19,15 @@ export function StaticLineGraph({
   lineThickness = 3,
   enableFadeInMask,
   style,
+  useSVG = false,
+  gradientFillColors,
   ...props
 }: StaticLineGraphProps): React.ReactElement {
   const [width, setWidth] = useState(0)
   const [height, setHeight] = useState(0)
 
+  const shouldFillGradient = gradientFillColors != null
+
   const onLayout = useCallback(
     ({ nativeEvent: { layout } }: LayoutChangeEvent) => {
       setWidth(Math.round(layout.width))
@@ -40,25 +46,60 @@ export function StaticLineGraph({
     [allPoints, pathRange]
   )
 
-  const path = useMemo(
-    () =>
-      createGraphPath({
+  const [path, gradientPath, pathSVG, gradientPathSVG] = useMemo(
+    () => {
+      const createGraphPathProps = {
         pointsInRange: pointsInRange,
         range: pathRange,
         canvasHeight: height,
         canvasWidth: width,
         horizontalPadding: lineThickness,
         verticalPadding: lineThickness,
-      }),
-    [height, lineThickness, pathRange, pointsInRange, width]
+      }
+
+      if (shouldFillGradient) {
+        const { path, gradientPath } = createGraphPathWithGradient(createGraphPathProps)
+        const pathSVG = useSVG && path !== undefined ? path.toSVGString() : ''
+        const gradientPathSVG = useSVG && gradientPath !== undefined ? gradientPath.toSVGString() : ''
+  
+        return [path, gradientPath, pathSVG, gradientPathSVG]
+      }
+
+      const path = createGraphPath(createGraphPathProps)
+      const pathSVG = useSVG && path !== undefined ? path.toSVGString() : ''
+
+      return [path, gradientPath, pathSVG, '']
+    },
+    [shouldFillGradient, height, lineThickness, pathRange, pointsInRange, width]
   )
 
+  const gradientFrom = useMemo(() => vec(0, 0), [])
+  const gradientTo = useMemo(() => vec(width * 0.15, 0), [width])
+
   const gradientColors = useMemo(
     () => [`${getSixDigitHex(color)}00`, `${getSixDigitHex(color)}ff`],
     [color]
   )
-  const gradientFrom = useMemo(() => vec(0, 0), [])
-  const gradientTo = useMemo(() => vec(width * 0.15, 0), [width])
+
+  if (useSVG) {
+    const stops = gradientFillColors ? gradientFillColors : []
+
+    return  (
+      <View {...props} style={style} onLayout={onLayout}>
+        <Svg height={height} width={width}>
+          <SVGPath d={pathSVG} stroke={color} strokeWidth={lineThickness} />
+          <SVGPath d={gradientPathSVG} fill="url(#gradient)"/>
+          <Defs>
+            <SVGLinearGradient id="gradient" x1="50%" y1="0%" x2="50%" y2="100%">
+              <Stop offset={'0%'} stopColor={stops[0]} stopOpacity="1" />
+              <Stop offset={'50%'} stopColor={stops[1]} stopOpacity="1" />
+              <Stop offset={'100%'} stopColor={stops[2]} stopOpacity="1" />
+            </SVGLinearGradient>
+          </Defs>
+        </Svg>
+      </View>
+    )
+  }
 
   return (
     <View {...props} style={style} onLayout={onLayout}>
@@ -96,6 +137,18 @@ export function StaticLineGraph({
             />
           )}
         </Path>
+        {shouldFillGradient && (
+          <Path
+            // @ts-ignore
+            path={gradientPath}
+          >
+            <LinearGradient
+              start={vec(0, 0)}
+              end={vec(0, height)}
+              colors={gradientFillColors}
+            />
+          </Path>
+        )}
       </Canvas>
     </View>
   )
@@ -106,3 +159,4 @@ const styles = StyleSheet.create({
     flex: 1,
   },
 })
+
