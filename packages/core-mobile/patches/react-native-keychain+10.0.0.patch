diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt
index 6b6e626..26c0e6d 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt
@@ -9,10 +9,10 @@ import android.util.Log
 import com.facebook.react.bridge.ReactApplicationContext
 import com.oblador.keychain.KeychainModule.KnownCiphers
 import com.oblador.keychain.SecurityLevel
+import com.oblador.keychain.exceptions.CryptoFailedException
 import com.oblador.keychain.resultHandler.CryptoContext
 import com.oblador.keychain.resultHandler.CryptoOperation
 import com.oblador.keychain.resultHandler.ResultHandler
-import com.oblador.keychain.exceptions.CryptoFailedException
 import java.io.IOException
 import java.security.GeneralSecurityException
 import java.security.Key
@@ -25,7 +25,8 @@ import javax.crypto.SecretKeyFactory
 import javax.crypto.spec.GCMParameterSpec
 
 class CipherStorageKeystoreAesGcm(
-    reactContext: ReactApplicationContext, private val requiresAuth: Boolean
+        reactContext: ReactApplicationContext,
+        private val requiresAuth: Boolean
 ) : CipherStorageBase(reactContext) {
 
     // region Constants
@@ -49,10 +50,11 @@ class CipherStorageKeystoreAesGcm(
     // endregion
 
     // region Configuration
-    override fun getCipherStorageName(): String = when (requiresAuth) {
-        true -> KnownCiphers.AES_GCM
-        false -> KnownCiphers.AES_GCM_NO_AUTH
-    }
+    override fun getCipherStorageName(): String =
+            when (requiresAuth) {
+                true -> KnownCiphers.AES_GCM
+                false -> KnownCiphers.AES_GCM_NO_AUTH
+            }
 
     /** API23 is a requirement. */
     override fun getMinSupportedApiLevel(): Int = Build.VERSION_CODES.M
@@ -75,11 +77,11 @@ class CipherStorageKeystoreAesGcm(
 
     @Throws(CryptoFailedException::class)
     override fun encrypt(
-        handler: ResultHandler,
-        alias: String,
-        username: String,
-        password: String,
-        level: SecurityLevel
+            handler: ResultHandler,
+            alias: String,
+            username: String,
+            password: String,
+            level: SecurityLevel
     ) {
 
         throwIfInsufficientLevel(level)
@@ -91,19 +93,23 @@ class CipherStorageKeystoreAesGcm(
         try {
             key = extractGeneratedKey(safeAlias, level, retries)
 
-            val result = CipherStorage.EncryptionResult(
-                encryptString(key, username), encryptString(key, password), this
-            )
+            val result =
+                    CipherStorage.EncryptionResult(
+                            encryptString(key, username),
+                            encryptString(key, password),
+                            this
+                    )
             handler.onEncrypt(result, null)
         } catch (ex: UserNotAuthenticatedException) {
             Log.d(LOG_TAG, "Unlock of keystore is needed. Error: ${ex.message}", ex)
-            val context = CryptoContext(
-                safeAlias,
-                key!!,
-                password.toByteArray(),
-                username.toByteArray(),
-                CryptoOperation.ENCRYPT
-            )
+            val context =
+                    CryptoContext(
+                            safeAlias,
+                            key!!,
+                            password.toByteArray(),
+                            username.toByteArray(),
+                            CryptoOperation.ENCRYPT
+                    )
 
             handler.askAccessPermissions(context)
         } catch (fail: Throwable) {
@@ -114,11 +120,11 @@ class CipherStorageKeystoreAesGcm(
     /** Redirect call to [decrypt] method. */
     @Throws(CryptoFailedException::class)
     override fun decrypt(
-        handler: ResultHandler,
-        alias: String,
-        username: ByteArray,
-        password: ByteArray,
-        level: SecurityLevel
+            handler: ResultHandler,
+            alias: String,
+            username: ByteArray,
+            password: ByteArray,
+            level: SecurityLevel
     ) {
         throwIfInsufficientLevel(level)
 
@@ -128,16 +134,19 @@ class CipherStorageKeystoreAesGcm(
 
         try {
             key = extractGeneratedKey(safeAlias, level, retries)
-            val results = CipherStorage.DecryptionResult(
-                decryptBytes(key, username), decryptBytes(key, password)
-            )
+            val results =
+                    CipherStorage.DecryptionResult(
+                            decryptBytes(key, username),
+                            decryptBytes(key, password)
+                    )
 
             handler.onDecrypt(results, null)
         } catch (ex: UserNotAuthenticatedException) {
             Log.d(LOG_TAG, "Unlock of keystore is needed. Error: ${ex.message}", ex)
-            // expected that KEY instance is extracted and we caught exception on decryptBytes operation
+            // expected that KEY instance is extracted and we caught exception on decryptBytes
+            // operation
             val context =
-                CryptoContext(safeAlias, key!!, password, username, CryptoOperation.DECRYPT)
+                    CryptoContext(safeAlias, key!!, password, username, CryptoOperation.DECRYPT)
 
             handler.askAccessPermissions(context)
         } catch (fail: Throwable) {
@@ -150,30 +159,30 @@ class CipherStorageKeystoreAesGcm(
 
     // region Implementation
 
-
     /** Get encryption algorithm specification builder instance. */
     @Throws(GeneralSecurityException::class)
     override fun getKeyGenSpecBuilder(
-        alias: String,
+            alias: String,
     ): KeyGenParameterSpec.Builder {
         val purposes = KeyProperties.PURPOSE_DECRYPT or KeyProperties.PURPOSE_ENCRYPT
 
-        val validityDuration = 5
         val keyGenParameterSpecBuilder =
-            KeyGenParameterSpec.Builder(alias, purposes).setBlockModes(BLOCK_MODE_GCM)
-                .setEncryptionPaddings(PADDING_NONE).setRandomizedEncryptionRequired(true)
-                .setKeySize(ENCRYPTION_KEY_SIZE)
+                KeyGenParameterSpec.Builder(alias, purposes)
+                        .setBlockModes(BLOCK_MODE_GCM)
+                        .setEncryptionPaddings(PADDING_NONE)
+                        .setRandomizedEncryptionRequired(true)
+                        .setKeySize(ENCRYPTION_KEY_SIZE)
 
         if (requiresAuth) {
             keyGenParameterSpecBuilder.setUserAuthenticationRequired(true)
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                 keyGenParameterSpecBuilder.setUserAuthenticationParameters(
-                    validityDuration,
-                    KeyProperties.AUTH_BIOMETRIC_STRONG or KeyProperties.AUTH_DEVICE_CREDENTIAL
+                        1,
+                        KeyProperties.AUTH_BIOMETRIC_STRONG or KeyProperties.AUTH_DEVICE_CREDENTIAL
                 )
             } else {
                 keyGenParameterSpecBuilder.setUserAuthenticationValidityDurationSeconds(
-                    validityDuration
+                        1
                 )
             }
         }
@@ -182,7 +191,6 @@ class CipherStorageKeystoreAesGcm(
     }
 
     /** Get information about provided key. */
-
     @Throws(GeneralSecurityException::class)
     override fun getKeyInfo(key: Key): KeyInfo {
         val factory = SecretKeyFactory.getInstance(key.algorithm, KEYSTORE_TYPE)
@@ -192,7 +200,6 @@ class CipherStorageKeystoreAesGcm(
     }
 
     /** Try to generate key from provided specification. */
-
     @Throws(GeneralSecurityException::class)
     override fun generateKey(spec: KeyGenParameterSpec): Key {
         val generator = KeyGenerator.getInstance(getEncryptionAlgorithm(), KEYSTORE_TYPE)
@@ -232,15 +239,13 @@ class CipherStorageKeystoreAesGcm(
         }
     }
 
-
     @Throws(GeneralSecurityException::class, IOException::class)
     override fun encryptString(key: Key, value: String): ByteArray =
-        encryptString(key, value, IV.encrypt)
-
+            encryptString(key, value, IV.encrypt)
 
     @Throws(GeneralSecurityException::class, IOException::class)
     override fun decryptBytes(key: Key, bytes: ByteArray): String =
-        decryptBytes(key, bytes, IV.decrypt)
+            decryptBytes(key, bytes, IV.decrypt)
 
     // endregion
 }
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt
index fc8ebf1..59cd083 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt
@@ -9,11 +9,11 @@ import android.util.Log
 import com.facebook.react.bridge.ReactApplicationContext
 import com.oblador.keychain.KeychainModule.KnownCiphers
 import com.oblador.keychain.SecurityLevel
+import com.oblador.keychain.exceptions.CryptoFailedException
+import com.oblador.keychain.exceptions.KeyStoreAccessException
 import com.oblador.keychain.resultHandler.CryptoContext
 import com.oblador.keychain.resultHandler.CryptoOperation
 import com.oblador.keychain.resultHandler.ResultHandler
-import com.oblador.keychain.exceptions.CryptoFailedException
-import com.oblador.keychain.exceptions.KeyStoreAccessException
 import java.io.IOException
 import java.security.GeneralSecurityException
 import java.security.InvalidKeyException
@@ -27,9 +27,8 @@ import java.security.spec.X509EncodedKeySpec
 import java.util.concurrent.atomic.AtomicInteger
 import javax.crypto.NoSuchPaddingException
 
-
 class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
-    CipherStorageBase(reactContext) {
+        CipherStorageBase(reactContext) {
 
     companion object {
         /** Selected algorithm. */
@@ -43,7 +42,7 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
 
         /** Composed transformation algorithms. */
         const val TRANSFORMATION_RSA_ECB_PKCS1: String =
-            "$ALGORITHM_RSA/$BLOCK_MODE_ECB/$PADDING_PKCS1"
+                "$ALGORITHM_RSA/$BLOCK_MODE_ECB/$PADDING_PKCS1"
 
         /** Selected encryption key size. */
         const val ENCRYPTION_KEY_SIZE = 2048
@@ -51,11 +50,11 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
 
     @Throws(CryptoFailedException::class)
     override fun encrypt(
-        handler: ResultHandler,
-        alias: String,
-        username: String,
-        password: String,
-        level: SecurityLevel
+            handler: ResultHandler,
+            alias: String,
+            username: String,
+            password: String,
+            level: SecurityLevel
     ) {
         throwIfInsufficientLevel(level)
 
@@ -73,16 +72,12 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
                 is InvalidKeyException -> {
                     throw CryptoFailedException("Could not encrypt data for service $alias", e)
                 }
-
-                is KeyStoreException,
-                is KeyStoreAccessException -> {
+                is KeyStoreException, is KeyStoreAccessException -> {
                     throw CryptoFailedException("Could not access Keystore for service $alias", e)
                 }
-
                 is IOException -> {
                     throw CryptoFailedException("I/O error: ${e.message}", e)
                 }
-
                 else -> {
                     throw CryptoFailedException("Unknown error: ${e.message}", e)
                 }
@@ -90,14 +85,13 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
         }
     }
 
-
     @Throws(CryptoFailedException::class)
     override fun decrypt(
-        handler: ResultHandler,
-        alias: String,
-        username: ByteArray,
-        password: ByteArray,
-        level: SecurityLevel
+            handler: ResultHandler,
+            alias: String,
+            username: ByteArray,
+            password: ByteArray,
+            level: SecurityLevel
     ) {
         throwIfInsufficientLevel(level)
 
@@ -110,18 +104,19 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
             key = extractGeneratedKey(safeAlias, level, retries)
 
             val results =
-                CipherStorage.DecryptionResult(
-                    decryptBytes(key, username),
-                    decryptBytes(key, password)
-                )
+                    CipherStorage.DecryptionResult(
+                            decryptBytes(key, username),
+                            decryptBytes(key, password)
+                    )
 
             handler.onDecrypt(results, null)
         } catch (ex: UserNotAuthenticatedException) {
             Log.d(LOG_TAG, "Unlock of keystore is needed. Error: ${ex.message}", ex)
 
-            // expected that KEY instance is extracted and we caught exception on decryptBytes operation
+            // expected that KEY instance is extracted and we caught exception on decryptBytes
+            // operation
             val context =
-                CryptoContext(safeAlias, key!!, password, username, CryptoOperation.DECRYPT)
+                    CryptoContext(safeAlias, key!!, password, username, CryptoOperation.DECRYPT)
 
             handler.askAccessPermissions(context)
         } catch (fail: Throwable) {
@@ -151,15 +146,16 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
      */
     @Throws(GeneralSecurityException::class, IOException::class)
     private fun innerEncryptedCredentials(
-        alias: String,
-        password: String,
-        username: String,
+            alias: String,
+            password: String,
+            username: String,
     ): CipherStorage.EncryptionResult {
         val keyStore = getKeyStoreAndLoad()
 
         // Retrieve the certificate after ensuring the key is compatible
-        val certificate = keyStore.getCertificate(alias)
-            ?: throw GeneralSecurityException("Certificate is null for alias $alias")
+        val certificate =
+                keyStore.getCertificate(alias)
+                        ?: throw GeneralSecurityException("Certificate is null for alias $alias")
 
         val publicKey = certificate.publicKey
         val kf = KeyFactory.getInstance(ALGORITHM_RSA)
@@ -167,37 +163,39 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
         val key = kf.generatePublic(keySpec)
 
         return CipherStorage.EncryptionResult(
-            encryptString(key, username), encryptString(key, password), this
+                encryptString(key, username),
+                encryptString(key, password),
+                this
         )
     }
 
-
     /** Get builder for encryption and decryption operations with required user Authentication. */
     @Throws(GeneralSecurityException::class)
     override fun getKeyGenSpecBuilder(
-        alias: String,
+            alias: String,
     ): KeyGenParameterSpec.Builder {
 
         val purposes = KeyProperties.PURPOSE_DECRYPT or KeyProperties.PURPOSE_ENCRYPT
 
         val keySize = ENCRYPTION_KEY_SIZE
 
-        val validityDuration = 5
         val keyGenParameterSpecBuilder =
-            KeyGenParameterSpec.Builder(alias, purposes)
-                .setBlockModes(BLOCK_MODE_ECB)
-                .setEncryptionPaddings(PADDING_PKCS1)
-                .setRandomizedEncryptionRequired(true)
-                .setUserAuthenticationRequired(true)
-                .setKeySize(keySize)
+                KeyGenParameterSpec.Builder(alias, purposes)
+                        .setBlockModes(BLOCK_MODE_ECB)
+                        .setEncryptionPaddings(PADDING_PKCS1)
+                        .setRandomizedEncryptionRequired(true)
+                        .setUserAuthenticationRequired(true)
+                        .setKeySize(keySize)
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
             keyGenParameterSpecBuilder.setUserAuthenticationParameters(
-                validityDuration,
-                KeyProperties.AUTH_BIOMETRIC_STRONG or KeyProperties.AUTH_DEVICE_CREDENTIAL
+                    1,
+                    KeyProperties.AUTH_BIOMETRIC_STRONG or KeyProperties.AUTH_DEVICE_CREDENTIAL
             )
         } else {
-            keyGenParameterSpecBuilder.setUserAuthenticationValidityDurationSeconds(validityDuration)
+            keyGenParameterSpecBuilder.setUserAuthenticationValidityDurationSeconds(
+                    1
+            )
         }
 
         return keyGenParameterSpecBuilder
