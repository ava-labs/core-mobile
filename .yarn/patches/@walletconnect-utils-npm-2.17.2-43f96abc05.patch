diff --git a/dist/index.cjs.js b/dist/index.cjs.js
index 1a1a79f1e7d7347b2891f2035abf0e164e35c75d..82054f6b8644e459d956d792bb31914d2ba544b3 100644
--- a/dist/index.cjs.js
+++ b/dist/index.cjs.js
@@ -1,10 +1,32 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var Zt=require("detect-browser"),U=require("@walletconnect/time"),P=require("@walletconnect/window-getters"),Xt=require("@walletconnect/window-metadata"),en=require("query-string"),Te=require("@ethersproject/hash"),tn=require("@ethersproject/transactions"),Ae=require("@stablelib/chacha20poly1305"),nn=require("@stablelib/hkdf"),B=require("@stablelib/random"),H=require("@stablelib/sha256"),rn=require("@stablelib/x25519"),p=require("uint8arrays"),on=require("elliptic"),sn=require("@walletconnect/relay-auth"),an=require("@walletconnect/relay-api");function Ie(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach(function(n){if(n!=="default"){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}}),t.default=e,Object.freeze(t)}var J=Ie(en),Pe=Ie(rn);const W=":";function ne(e){const[t,n]=e.split(W);return{namespace:t,reference:n}}function Ce(e){const{namespace:t,reference:n}=e;return[t,n].join(W)}function re(e){const[t,n,r]=e.split(W);return{namespace:t,reference:n,address:r}}function $e(e){const{namespace:t,reference:n,address:r}=e;return[t,n,r].join(W)}function oe(e,t){const n=[];return e.forEach(r=>{const o=t(r);n.includes(o)||n.push(o)}),n}function je(e){const{address:t}=re(e);return t}function _e(e){const{namespace:t,reference:n}=re(e);return Ce({namespace:t,reference:n})}function cn(e,t){const{namespace:n,reference:r}=ne(t);return $e({namespace:n,reference:r,address:e})}function un(e){return oe(e,je)}function Ue(e){return oe(e,_e)}function ln(e,t=[]){const n=[];return Object.keys(e).forEach(r=>{if(t.length&&!t.includes(r))return;const o=e[r];n.push(...o.accounts)}),n}function dn(e,t=[]){const n=[];return Object.keys(e).forEach(r=>{if(t.length&&!t.includes(r))return;const o=e[r];n.push(...Ue(o.accounts))}),n}function pn(e,t=[]){const n=[];return Object.keys(e).forEach(r=>{if(t.length&&!t.includes(r))return;const o=e[r];n.push(...z(r,o))}),n}function z(e,t){return e.includes(":")?[e]:t.chains||[]}var fn=Object.defineProperty,De=Object.getOwnPropertySymbols,mn=Object.prototype.hasOwnProperty,gn=Object.prototype.propertyIsEnumerable,Ve=(e,t,n)=>t in e?fn(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,ke=(e,t)=>{for(var n in t||(t={}))mn.call(t,n)&&Ve(e,n,t[n]);if(De)for(var n of De(t))gn.call(t,n)&&Ve(e,n,t[n]);return e};const xe="ReactNative",y={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},Y=" ",hn=":",Me="/",se=2,yn=1e3,Fe="js";function ie(){return typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"}function D(){return!P.getDocument()&&!!P.getNavigator()&&navigator.product===xe}function M(){return!ie()&&!!P.getNavigator()&&!!P.getDocument()}function C(){return D()?y.reactNative:ie()?y.node:M()?y.browser:y.unknown}function vn(){var e;try{return D()&&typeof global<"u"&&typeof(global==null?void 0:global.Application)<"u"?(e=global.Application)==null?void 0:e.applicationId:void 0}catch{return}}function Le(e,t){let n=J.parse(e);return n=ke(ke({},n),t),e=J.stringify(n),e}function En(){return Xt.getWindowMetadata()||{name:"",description:"",url:"",icons:[""]}}function bn(e,t){var n;const r=C(),o={protocol:e,version:t,env:r};return r==="browser"&&(o.host=((n=P.getLocation())==null?void 0:n.host)||"unknown"),o}function Ke(){if(C()===y.reactNative&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"){const{OS:n,Version:r}=global.Platform;return[n,r].join("-")}const e=Zt.detect();if(e===null)return"unknown";const t=e.os?e.os.replace(" ","").toLowerCase():"unknown";return e.type==="browser"?[t,e.name,e.version].join("-"):[t,e.version].join("-")}function qe(){var e;const t=C();return t===y.browser?[t,((e=P.getLocation())==null?void 0:e.host)||"unknown"].join(":"):t}function Be(e,t,n){const r=Ke(),o=qe();return[[e,t].join("-"),[Fe,n].join("-"),r,o].join("/")}function Nn({protocol:e,version:t,relayUrl:n,sdkVersion:r,auth:o,projectId:s,useOnCloseEvent:i,bundleId:u}){const l=n.split("?"),a=Be(e,t,r),d={auth:o,ua:a,projectId:s,useOnCloseEvent:i||void 0,origin:u||void 0},c=Le(l[1]||"",d);return l[0]+"?"+c}function On(e){let t=(e.match(/^[^:]+(?=:\/\/)/gi)||[])[0];const n=typeof t<"u"?e.split("://")[1]:e;return t=t==="wss"?"https":"http",[t,n].join("://")}function Sn(e,t,n){if(!e[t]||typeof e[t]!==n)throw new Error(`Missing or invalid "${t}" param`)}function He(e,t=se){return Je(e.split(Me),t)}function wn(e){return He(e).join(Y)}function w(e,t){return e.filter(n=>t.includes(n)).length===e.length}function Je(e,t=se){return e.slice(Math.max(e.length-t,0))}function Rn(e){return Object.fromEntries(e.entries())}function Tn(e){return new Map(Object.entries(e))}function An(e,t){const n={};return Object.keys(e).forEach(r=>{n[r]=t(e[r])}),n}const In=e=>e;function We(e){return e.trim().replace(/^\w/,t=>t.toUpperCase())}function Pn(e){return e.split(Y).map(t=>We(t)).join(Y)}function Cn(e=U.FIVE_MINUTES,t){const n=U.toMiliseconds(e||U.FIVE_MINUTES);let r,o,s;return{resolve:i=>{s&&r&&(clearTimeout(s),r(i))},reject:i=>{s&&o&&(clearTimeout(s),o(i))},done:()=>new Promise((i,u)=>{s=setTimeout(()=>{u(new Error(t))},n),r=i,o=u})}}function $n(e,t,n){return new Promise(async(r,o)=>{const s=setTimeout(()=>o(new Error(n)),t);try{const i=await e;r(i)}catch(i){o(i)}clearTimeout(s)})}function ae(e,t){if(typeof t=="string"&&t.startsWith(`${e}:`))return t;if(e.toLowerCase()==="topic"){if(typeof t!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${t}`}else if(e.toLowerCase()==="id"){if(typeof t!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${t}`}throw new Error(`Unknown expirer target type: ${e}`)}function jn(e){return ae("topic",e)}function _n(e){return ae("id",e)}function Un(e){const[t,n]=e.split(":"),r={id:void 0,topic:void 0};if(t==="topic"&&typeof n=="string")r.topic=n;else if(t==="id"&&Number.isInteger(Number(n)))r.id=Number(n);else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`);return r}function Dn(e,t){return U.fromMiliseconds((t||Date.now())+U.toMiliseconds(e))}function Vn(e){return Date.now()>=U.toMiliseconds(e)}function kn(e,t){return`${e}${t?`:${t}`:""}`}function O(e=[],t=[]){return[...new Set([...e,...t])]}async function xn({id:e,topic:t,wcDeepLink:n}){var r;try{if(!n)return;const o=typeof n=="string"?JSON.parse(n):n,s=o?.href;if(typeof s!="string")return;const i=ze(s,e,t),u=C();if(u===y.browser){if(!((r=P.getDocument())!=null&&r.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}i.startsWith("https://")||i.startsWith("http://")?window.open(i,"_blank","noreferrer noopener"):window.open(i,Ye()?"_blank":"_self","noreferrer noopener")}else u===y.reactNative&&typeof(global==null?void 0:global.Linking)<"u"&&await global.Linking.openURL(i)}catch(o){console.error(o)}}function ze(e,t,n){const r=`requestId=${t}&sessionTopic=${n}`;e.endsWith("/")&&(e=e.slice(0,-1));let o=`${e}`;if(e.startsWith("https://t.me")){const s=e.includes("?")?"&startapp=":"?startapp=";o=`${o}${s}${Ge(r,!0)}`}else o=`${o}/wc?${r}`;return o}async function Mn(e,t){let n="";try{if(M()&&(n=localStorage.getItem(t),n))return n;n=await e.getItem(t)}catch(r){console.error(r)}return n}function ce(e,t){return e.filter(n=>t.includes(n))}function Fn(e,t){if(!e.includes(t))return null;const n=e.split(/([&,?,=])/),r=n.indexOf(t);return n[r+2]}function Ln(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,e=>{const t=Math.random()*16|0;return(e==="x"?t:t&3|8).toString(16)})}function Kn(){return typeof process<"u"&&process.env.IS_VITEST==="true"}function Ye(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function Ge(e,t=!1){const n=Buffer.from(e).toString("base64");return t?n.replace(/[=]/g,""):n}function ue(e){return Buffer.from(e,"base64").toString("utf-8")}const qn="https://rpc.walletconnect.org/v1";async function Qe(e,t,n,r,o,s){switch(n.t){case"eip191":return Ze(e,t,n.s);case"eip1271":return await Xe(e,t,n.s,r,o,s);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`)}}function Ze(e,t,n){return tn.recoverAddress(Te.hashMessage(t),n).toLowerCase()===e.toLowerCase()}async function Xe(e,t,n,r,o,s){const i=ne(r);if(!i.namespace||!i.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);try{const u="0x1626ba7e",l="0000000000000000000000000000000000000000000000000000000000000040",a="0000000000000000000000000000000000000000000000000000000000000041",d=n.substring(2),c=Te.hashMessage(t).substring(2),f=u+c+l+a+d,h=await fetch(`${s||qn}/?chainId=${r}&projectId=${o}`,{method:"POST",body:JSON.stringify({id:Bn(),jsonrpc:"2.0",method:"eth_call",params:[{to:e,data:f},"latest"]})}),{result:m}=await h.json();return m?m.slice(0,u.length).toLowerCase()===u.toLowerCase():!1}catch(u){return console.error("isValidEip1271Signature: ",u),!1}}function Bn(){return Date.now()+Math.floor(Math.random()*1e3)}var Hn=Object.defineProperty,Jn=Object.defineProperties,Wn=Object.getOwnPropertyDescriptors,et=Object.getOwnPropertySymbols,zn=Object.prototype.hasOwnProperty,Yn=Object.prototype.propertyIsEnumerable,tt=(e,t,n)=>t in e?Hn(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,le=(e,t)=>{for(var n in t||(t={}))zn.call(t,n)&&tt(e,n,t[n]);if(et)for(var n of et(t))Yn.call(t,n)&&tt(e,n,t[n]);return e},nt=(e,t)=>Jn(e,Wn(t));const Gn="did:pkh:",G=e=>e?.split(":"),rt=e=>{const t=e&&G(e);if(t)return e.includes(Gn)?t[3]:t[1]},ot=e=>{const t=e&&G(e);if(t)return t[2]+":"+t[3]},de=e=>{const t=e&&G(e);if(t)return t.pop()};async function Qn(e){const{cacao:t,projectId:n}=e,{s:r,p:o}=t,s=st(o,o.iss),i=de(o.iss);return await Qe(i,s,r,ot(o.iss),n)}const st=(e,t)=>{const n=`${e.domain} wants you to sign in with your Ethereum account:`,r=de(t);if(!e.aud&&!e.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let o=e.statement||void 0;const s=`URI: ${e.aud||e.uri}`,i=`Version: ${e.version}`,u=`Chain ID: ${rt(t)}`,l=`Nonce: ${e.nonce}`,a=`Issued At: ${e.iat}`,d=e.exp?`Expiration Time: ${e.exp}`:void 0,c=e.nbf?`Not Before: ${e.nbf}`:void 0,f=e.requestId?`Request ID: ${e.requestId}`:void 0,h=e.resources?`Resources:${e.resources.map(g=>`
-- ${g}`).join("")}`:void 0,m=Z(e.resources);if(m){const g=R(m);o=me(o,g)}return[n,r,"",o,"",s,i,u,l,a,d,c,f,h].filter(g=>g!=null).join(`
-`)};function Zn(e,t,n){return n.includes("did:pkh:")||(n=`did:pkh:${n}`),{h:{t:"caip122"},p:{iss:n,domain:e.domain,aud:e.aud,version:e.version,nonce:e.nonce,iat:e.iat,statement:e.statement,requestId:e.requestId,resources:e.resources,nbf:e.nbf,exp:e.exp},s:t}}function Xn(e){var t;const{authPayload:n,chains:r,methods:o}=e,s=n.statement||"";if(!(r!=null&&r.length))return n;const i=n.chains,u=ce(i,r);if(!(u!=null&&u.length))throw new Error("No supported chains");const l=it(n.resources);if(!l)return n;N(l);const a=at(l,"eip155");let d=n?.resources||[];if(a!=null&&a.length){const c=ct(a),f=ce(c,o);if(!(f!=null&&f.length))throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(c)}, supported: ${JSON.stringify(o)}`);const h=pe("request",f,{chains:u}),m=pt(l,"eip155",h);d=((t=n?.resources)==null?void 0:t.slice(0,-1))||[],d.push(Q(m))}return nt(le({},n),{statement:mt(s,Z(d)),chains:u,resources:n!=null&&n.resources||d.length>0?d:void 0})}function it(e){const t=Z(e);if(t&&fe(t))return R(t)}function er(e,t){var n;return(n=e?.att)==null?void 0:n.hasOwnProperty(t)}function at(e,t){var n,r;return(n=e?.att)!=null&&n[t]?Object.keys((r=e?.att)==null?void 0:r[t]):[]}function tr(e){return e?.map(t=>Object.keys(t))||[]}function ct(e){return e?.map(t=>{var n;return(n=t.split("/"))==null?void 0:n[1]})||[]}function ut(e){return Buffer.from(JSON.stringify(e)).toString("base64")}function lt(e){return JSON.parse(Buffer.from(e,"base64").toString("utf-8"))}function N(e){if(!e)throw new Error("No recap provided, value is undefined");if(!e.att)throw new Error("No `att` property found");const t=Object.keys(e.att);if(!(t!=null&&t.length))throw new Error("No resources found in `att` property");t.forEach(n=>{const r=e.att[n];if(Array.isArray(r))throw new Error(`Resource must be an object: ${n}`);if(typeof r!="object")throw new Error(`Resource must be an object: ${n}`);if(!Object.keys(r).length)throw new Error(`Resource object is empty: ${n}`);Object.keys(r).forEach(o=>{const s=r[o];if(!Array.isArray(s))throw new Error(`Ability limits ${o} must be an array of objects, found: ${s}`);if(!s.length)throw new Error(`Value of ${o} is empty array, must be an array with objects`);s.forEach(i=>{if(typeof i!="object")throw new Error(`Ability limits (${o}) must be an array of objects, found: ${i}`)})})})}function dt(e,t,n,r={}){return n?.sort((o,s)=>o.localeCompare(s)),{att:{[e]:pe(t,n,r)}}}function pt(e,t,n){var r;return e.att[t]=le({},n),((r=Object.keys(e.att))==null?void 0:r.sort((o,s)=>o.localeCompare(s))).reduce((o,s)=>(o.att[s]=e.att[s],o),{att:{}})}function pe(e,t,n={}){t=t?.sort((o,s)=>o.localeCompare(s));const r=t.map(o=>({[`${e}/${o}`]:[n]}));return Object.assign({},...r)}function Q(e){return N(e),`urn:recap:${ut(e).replace(/=/g,"")}`}function R(e){const t=lt(e.replace("urn:recap:",""));return N(t),t}function nr(e,t,n){const r=dt(e,t,n);return Q(r)}function fe(e){return e&&e.includes("urn:recap:")}function rr(e,t){const n=R(e),r=R(t),o=ft(n,r);return Q(o)}function ft(e,t){N(e),N(t);const n=Object.keys(e.att).concat(Object.keys(t.att)).sort((o,s)=>o.localeCompare(s)),r={att:{}};return n.forEach(o=>{var s,i;Object.keys(((s=e.att)==null?void 0:s[o])||{}).concat(Object.keys(((i=t.att)==null?void 0:i[o])||{})).sort((u,l)=>u.localeCompare(l)).forEach(u=>{var l,a;r.att[o]=nt(le({},r.att[o]),{[u]:((l=e.att[o])==null?void 0:l[u])||((a=t.att[o])==null?void 0:a[u])})})}),r}function me(e="",t){N(t);const n="I further authorize the stated URI to perform the following actions on my behalf: ";if(e.includes(n))return e;const r=[];let o=0;Object.keys(t.att).forEach(u=>{const l=Object.keys(t.att[u]).map(c=>({ability:c.split("/")[0],action:c.split("/")[1]}));l.sort((c,f)=>c.action.localeCompare(f.action));const a={};l.forEach(c=>{a[c.ability]||(a[c.ability]=[]),a[c.ability].push(c.action)});const d=Object.keys(a).map(c=>(o++,`(${o}) '${c}': '${a[c].join("', '")}' for '${u}'.`));r.push(d.join(", ").replace(".,","."))});const s=r.join(" "),i=`${n}${s}`;return`${e?e+" ":""}${i}`}function or(e){var t;const n=R(e);N(n);const r=(t=n.att)==null?void 0:t.eip155;return r?Object.keys(r).map(o=>o.split("/")[1]):[]}function sr(e){const t=R(e);N(t);const n=[];return Object.values(t.att).forEach(r=>{Object.values(r).forEach(o=>{var s;(s=o?.[0])!=null&&s.chains&&n.push(o[0].chains)})}),[...new Set(n.flat())]}function mt(e,t){if(!t)return e;const n=R(t);return N(n),me(e,n)}function Z(e){if(!e)return;const t=e?.[e.length-1];return fe(t)?t:void 0}const ge="base10",v="base16",he="base64pad",ir="base64url",V="utf8",ye=0,k=1,F=2,ar=0,gt=1,L=12,ve=32;function cr(){const e=Pe.generateKeyPair();return{privateKey:p.toString(e.secretKey,v),publicKey:p.toString(e.publicKey,v)}}function ur(){const e=B.randomBytes(ve);return p.toString(e,v)}function lr(e,t){const n=Pe.sharedKey(p.fromString(e,v),p.fromString(t,v),!0),r=new nn.HKDF(H.SHA256,n).expand(ve);return p.toString(r,v)}function dr(e){const t=H.hash(p.fromString(e,v));return p.toString(t,v)}function pr(e){const t=H.hash(p.fromString(e,V));return p.toString(t,v)}function Ee(e){return p.fromString(`${e}`,ge)}function $(e){return Number(p.toString(e,ge))}function fr(e){const t=Ee(typeof e.type<"u"?e.type:ye);if($(t)===k&&typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const n=typeof e.senderPublicKey<"u"?p.fromString(e.senderPublicKey,v):void 0,r=typeof e.iv<"u"?p.fromString(e.iv,v):B.randomBytes(L),o=new Ae.ChaCha20Poly1305(p.fromString(e.symKey,v)).seal(r,p.fromString(e.message,V));return be({type:t,sealed:o,iv:r,senderPublicKey:n,encoding:e.encoding})}function mr(e,t){const n=Ee(F),r=B.randomBytes(L),o=p.fromString(e,V);return be({type:n,sealed:o,iv:r,encoding:t})}function gr(e){const t=new Ae.ChaCha20Poly1305(p.fromString(e.symKey,v)),{sealed:n,iv:r}=X({encoded:e.encoded,encoding:e?.encoding}),o=t.open(r,n);if(o===null)throw new Error("Failed to decrypt");return p.toString(o,V)}function hr(e,t){const{sealed:n}=X({encoded:e,encoding:t});return p.toString(n,V)}function be(e){const{encoding:t=he}=e;if($(e.type)===F)return p.toString(p.concat([e.type,e.sealed]),t);if($(e.type)===k){if(typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return p.toString(p.concat([e.type,e.senderPublicKey,e.iv,e.sealed]),t)}return p.toString(p.concat([e.type,e.iv,e.sealed]),t)}function X(e){const{encoded:t,encoding:n=he}=e,r=p.fromString(t,n),o=r.slice(ar,gt),s=gt;if($(o)===k){const a=s+ve,d=a+L,c=r.slice(s,a),f=r.slice(a,d),h=r.slice(d);return{type:o,sealed:h,iv:f,senderPublicKey:c}}if($(o)===F){const a=r.slice(s),d=B.randomBytes(L);return{type:o,sealed:a,iv:d}}const i=s+L,u=r.slice(s,i),l=r.slice(i);return{type:o,sealed:l,iv:u}}function yr(e,t){const n=X({encoded:e,encoding:t?.encoding});return ht({type:$(n.type),senderPublicKey:typeof n.senderPublicKey<"u"?p.toString(n.senderPublicKey,v):void 0,receiverPublicKey:t?.receiverPublicKey})}function ht(e){const t=e?.type||ye;if(t===k){if(typeof e?.senderPublicKey>"u")throw new Error("missing sender public key");if(typeof e?.receiverPublicKey>"u")throw new Error("missing receiver public key")}return{type:t,senderPublicKey:e?.senderPublicKey,receiverPublicKey:e?.receiverPublicKey}}function vr(e){return e.type===k&&typeof e.senderPublicKey=="string"&&typeof e.receiverPublicKey=="string"}function Er(e){return e.type===F}function yt(e){return new on.ec("p256").keyFromPublic({x:Buffer.from(e.x,"base64").toString("hex"),y:Buffer.from(e.y,"base64").toString("hex")},"hex")}function br(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");const n=t.length%4;return n>0&&(t+="=".repeat(4-n)),t}function Nr(e){return Buffer.from(br(e),"base64")}function Or(e,t){const[n,r,o]=e.split("."),s=Nr(o);if(s.length!==64)throw new Error("Invalid signature length");const i=s.slice(0,32).toString("hex"),u=s.slice(32,64).toString("hex"),l=`${n}.${r}`,a=new H.SHA256().update(Buffer.from(l)).digest(),d=yt(t),c=Buffer.from(a).toString("hex");if(!d.verify(c,{r:i,s:u}))throw new Error("Invalid signature");return sn.decodeJWT(e).payload}const vt="irn";function Sr(e){return e?.relay||{protocol:vt}}function wr(e){const t=an.RELAY_JSONRPC[e];if(typeof t>"u")throw new Error(`Relay Protocol not supported: ${e}`);return t}var Rr=Object.defineProperty,Tr=Object.defineProperties,Ar=Object.getOwnPropertyDescriptors,Et=Object.getOwnPropertySymbols,Ir=Object.prototype.hasOwnProperty,Pr=Object.prototype.propertyIsEnumerable,bt=(e,t,n)=>t in e?Rr(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Nt=(e,t)=>{for(var n in t||(t={}))Ir.call(t,n)&&bt(e,n,t[n]);if(Et)for(var n of Et(t))Pr.call(t,n)&&bt(e,n,t[n]);return e},Cr=(e,t)=>Tr(e,Ar(t));function Ot(e,t="-"){const n={},r="relay"+t;return Object.keys(e).forEach(o=>{if(o.startsWith(r)){const s=o.replace(r,""),i=e[o];n[s]=i}}),n}function $r(e){if(!e.includes("wc:")){const l=ue(e);l!=null&&l.includes("wc:")&&(e=l)}e=e.includes("wc://")?e.replace("wc://",""):e,e=e.includes("wc:")?e.replace("wc:",""):e;const t=e.indexOf(":"),n=e.indexOf("?")!==-1?e.indexOf("?"):void 0,r=e.substring(0,t),o=e.substring(t+1,n).split("@"),s=typeof n<"u"?e.substring(n):"",i=J.parse(s),u=typeof i.methods=="string"?i.methods.split(","):void 0;return{protocol:r,topic:St(o[0]),version:parseInt(o[1],10),symKey:i.symKey,relay:Ot(i),methods:u,expiryTimestamp:i.expiryTimestamp?parseInt(i.expiryTimestamp,10):void 0}}function St(e){return e.startsWith("//")?e.substring(2):e}function wt(e,t="-"){const n="relay",r={};return Object.keys(e).forEach(o=>{const s=n+t+o;e[o]&&(r[s]=e[o])}),r}function jr(e){return`${e.protocol}:${e.topic}@${e.version}?`+J.stringify(Nt(Cr(Nt({symKey:e.symKey},wt(e.relay)),{expiryTimestamp:e.expiryTimestamp}),e.methods?{methods:e.methods.join(",")}:{}))}function _r(e,t,n){return`${e}?wc_ev=${n}&topic=${t}`}var Ur=Object.defineProperty,Dr=Object.defineProperties,Vr=Object.getOwnPropertyDescriptors,Rt=Object.getOwnPropertySymbols,kr=Object.prototype.hasOwnProperty,xr=Object.prototype.propertyIsEnumerable,Tt=(e,t,n)=>t in e?Ur(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Mr=(e,t)=>{for(var n in t||(t={}))kr.call(t,n)&&Tt(e,n,t[n]);if(Rt)for(var n of Rt(t))xr.call(t,n)&&Tt(e,n,t[n]);return e},Fr=(e,t)=>Dr(e,Vr(t));function j(e){const t=[];return e.forEach(n=>{const[r,o]=n.split(":");t.push(`${r}:${o}`)}),t}function At(e){const t=[];return Object.values(e).forEach(n=>{t.push(...j(n.accounts))}),t}function It(e,t){const n=[];return Object.values(e).forEach(r=>{j(r.accounts).includes(t)&&n.push(...r.methods)}),n}function Pt(e,t){const n=[];return Object.values(e).forEach(r=>{j(r.accounts).includes(t)&&n.push(...r.events)}),n}function Lr(e,t){const n=Ft(e,t);if(n)throw new Error(n.message);const r={};for(const[o,s]of Object.entries(e))r[o]={methods:s.methods,events:s.events,chains:s.accounts.map(i=>`${i.split(":")[0]}:${i.split(":")[1]}`)};return r}function Kr(e){const{proposal:{requiredNamespaces:t,optionalNamespaces:n={}},supportedNamespaces:r}=e,o=Oe(t),s=Oe(n),i={};Object.keys(r).forEach(a=>{const d=r[a].chains,c=r[a].methods,f=r[a].events,h=r[a].accounts;d.forEach(m=>{if(!h.some(g=>g.includes(m)))throw new Error(`No accounts provided for chain ${m} in namespace ${a}`)}),i[a]={chains:d,methods:c,events:f,accounts:h}});const u=Kt(t,i,"approve()");if(u)throw new Error(u.message);const l={};return!Object.keys(t).length&&!Object.keys(n).length?i:(Object.keys(o).forEach(a=>{const d=r[a].chains.filter(m=>{var g,b;return(b=(g=o[a])==null?void 0:g.chains)==null?void 0:b.includes(m)}),c=r[a].methods.filter(m=>{var g,b;return(b=(g=o[a])==null?void 0:g.methods)==null?void 0:b.includes(m)}),f=r[a].events.filter(m=>{var g,b;return(b=(g=o[a])==null?void 0:g.events)==null?void 0:b.includes(m)}),h=d.map(m=>r[a].accounts.filter(g=>g.includes(`${m}:`))).flat();l[a]={chains:d,methods:c,events:f,accounts:h}}),Object.keys(s).forEach(a=>{var d,c,f,h,m,g;if(!r[a])return;const b=(c=(d=s[a])==null?void 0:d.chains)==null?void 0:c.filter(A=>r[a].chains.includes(A)),Yt=r[a].methods.filter(A=>{var I,x;return(x=(I=s[a])==null?void 0:I.methods)==null?void 0:x.includes(A)}),Gt=r[a].events.filter(A=>{var I,x;return(x=(I=s[a])==null?void 0:I.events)==null?void 0:x.includes(A)}),Qt=b?.map(A=>r[a].accounts.filter(I=>I.includes(`${A}:`))).flat();l[a]={chains:O((f=l[a])==null?void 0:f.chains,b),methods:O((h=l[a])==null?void 0:h.methods,Yt),events:O((m=l[a])==null?void 0:m.events,Gt),accounts:O((g=l[a])==null?void 0:g.accounts,Qt)}}),l)}function Ne(e){return e.includes(":")}function Ct(e){return Ne(e)?e.split(":")[0]:e}function Oe(e){var t,n,r;const o={};if(!ee(e))return o;for(const[s,i]of Object.entries(e)){const u=Ne(s)?[s]:i.chains,l=i.methods||[],a=i.events||[],d=Ct(s);o[d]=Fr(Mr({},o[d]),{chains:O(u,(t=o[d])==null?void 0:t.chains),methods:O(l,(n=o[d])==null?void 0:n.methods),events:O(a,(r=o[d])==null?void 0:r.events)})}return o}function $t(e){const t={};return e?.forEach(n=>{const[r,o]=n.split(":");t[r]||(t[r]={accounts:[],chains:[],events:[]}),t[r].accounts.push(n),t[r].chains.push(`${r}:${o}`)}),t}function qr(e,t){t=t.map(r=>r.replace("did:pkh:",""));const n=$t(t);for(const[r,o]of Object.entries(n))o.methods?o.methods=O(o.methods,e):o.methods=e,o.events=["chainChanged","accountsChanged"];return n}const jt={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},_t={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function S(e,t){const{message:n,code:r}=_t[e];return{message:t?`${n} ${t}`:n,code:r}}function _(e,t){const{message:n,code:r}=jt[e];return{message:t?`${n} ${t}`:n,code:r}}function K(e,t){return Array.isArray(e)?typeof t<"u"&&e.length?e.every(t):!0:!1}function ee(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function T(e){return typeof e>"u"}function E(e,t){return t&&T(e)?!0:typeof e=="string"&&!!e.trim().length}function te(e,t){return t&&T(e)?!0:typeof e=="number"&&!isNaN(e)}function Br(e,t){const{requiredNamespaces:n}=t,r=Object.keys(e.namespaces),o=Object.keys(n);let s=!0;return w(o,r)?(r.forEach(i=>{const{accounts:u,methods:l,events:a}=e.namespaces[i],d=j(u),c=n[i];(!w(z(i,c),d)||!w(c.methods,l)||!w(c.events,a))&&(s=!1)}),s):!1}function q(e){return E(e,!1)&&e.includes(":")?e.split(":").length===2:!1}function Ut(e){if(E(e,!1)&&e.includes(":")){const t=e.split(":");if(t.length===3){const n=t[0]+":"+t[1];return!!t[2]&&q(n)}}return!1}function Hr(e){function t(n){try{return typeof new URL(n)<"u"}catch{return!1}}try{if(E(e,!1)){if(t(e))return!0;const n=ue(e);return t(n)}}catch{}return!1}function Jr(e){var t;return(t=e?.proposer)==null?void 0:t.publicKey}function Wr(e){return e?.topic}function zr(e,t){let n=null;return E(e?.publicKey,!1)||(n=S("MISSING_OR_INVALID",`${t} controller public key should be a string`)),n}function Se(e){let t=!0;return K(e)?e.length&&(t=e.every(n=>E(n,!1))):t=!1,t}function Dt(e,t,n){let r=null;return K(t)&&t.length?t.forEach(o=>{r||q(o)||(r=_("UNSUPPORTED_CHAINS",`${n}, chain ${o} should be a string and conform to "namespace:chainId" format`))}):q(e)||(r=_("UNSUPPORTED_CHAINS",`${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),r}function Vt(e,t,n){let r=null;return Object.entries(e).forEach(([o,s])=>{if(r)return;const i=Dt(o,z(o,s),`${t} ${n}`);i&&(r=i)}),r}function kt(e,t){let n=null;return K(e)?e.forEach(r=>{n||Ut(r)||(n=_("UNSUPPORTED_ACCOUNTS",`${t}, account ${r} should be a string and conform to "namespace:chainId:address" format`))}):n=_("UNSUPPORTED_ACCOUNTS",`${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),n}function xt(e,t){let n=null;return Object.values(e).forEach(r=>{if(n)return;const o=kt(r?.accounts,`${t} namespace`);o&&(n=o)}),n}function Mt(e,t){let n=null;return Se(e?.methods)?Se(e?.events)||(n=_("UNSUPPORTED_EVENTS",`${t}, events should be an array of strings or empty array for no events`)):n=_("UNSUPPORTED_METHODS",`${t}, methods should be an array of strings or empty array for no methods`),n}function we(e,t){let n=null;return Object.values(e).forEach(r=>{if(n)return;const o=Mt(r,`${t}, namespace`);o&&(n=o)}),n}function Yr(e,t,n){let r=null;if(e&&ee(e)){const o=we(e,t);o&&(r=o);const s=Vt(e,t,n);s&&(r=s)}else r=S("MISSING_OR_INVALID",`${t}, ${n} should be an object with data`);return r}function Ft(e,t){let n=null;if(e&&ee(e)){const r=we(e,t);r&&(n=r);const o=xt(e,t);o&&(n=o)}else n=S("MISSING_OR_INVALID",`${t}, namespaces should be an object with data`);return n}function Lt(e){return E(e.protocol,!0)}function Gr(e,t){let n=!1;return t&&!e?n=!0:e&&K(e)&&e.length&&e.forEach(r=>{n=Lt(r)}),n}function Qr(e){return typeof e=="number"}function Zr(e){return typeof e<"u"&&typeof e!==null}function Xr(e){return!(!e||typeof e!="object"||!e.code||!te(e.code,!1)||!e.message||!E(e.message,!1))}function eo(e){return!(T(e)||!E(e.method,!1))}function to(e){return!(T(e)||T(e.result)&&T(e.error)||!te(e.id,!1)||!E(e.jsonrpc,!1))}function no(e){return!(T(e)||!E(e.name,!1))}function ro(e,t){return!(!q(t)||!At(e).includes(t))}function oo(e,t,n){return E(n,!1)?It(e,t).includes(n):!1}function so(e,t,n){return E(n,!1)?Pt(e,t).includes(n):!1}function Kt(e,t,n){let r=null;const o=io(e),s=ao(t),i=Object.keys(o),u=Object.keys(s),l=qt(Object.keys(e)),a=qt(Object.keys(t)),d=l.filter(c=>!a.includes(c));return d.length&&(r=S("NON_CONFORMING_NAMESPACES",`${n} namespaces keys don't satisfy requiredNamespaces.
+
+function uniq(arr) {
+  const seen = Object.create(null);
+  const out = [];
+  for (let i = 0, len = arr.length; i < len; i++) {
+    const val = arr[i];
+    // key must be string — handles numbers, strings, booleans fine
+    const key = typeof val + val;
+    if (seen[key] === undefined) {
+      seen[key] = true;
+      out.push(val);
+    }
+  }
+  return out;
+}
+
+"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); var Zt = require("detect-browser"), U = require("@walletconnect/time"), P = require("@walletconnect/window-getters"), Xt = require("@walletconnect/window-metadata"), en = require("query-string"), Te = require("@ethersproject/hash"), tn = require("@ethersproject/transactions"), Ae = require("@stablelib/chacha20poly1305"), nn = require("@stablelib/hkdf"), B = require("@stablelib/random"), H = require("@stablelib/sha256"), rn = require("@stablelib/x25519"), p = require("uint8arrays"), on = require("elliptic"), sn = require("@walletconnect/relay-auth"), an = require("@walletconnect/relay-api"); function Ie(e) { if (e && e.__esModule) return e; var t = Object.create(null); return e && Object.keys(e).forEach(function (n) { if (n !== "default") { var r = Object.getOwnPropertyDescriptor(e, n); Object.defineProperty(t, n, r.get ? r : { enumerable: !0, get: function () { return e[n] } }) } }), t.default = e, Object.freeze(t) } var J = Ie(en), Pe = Ie(rn); const W = ":"; function ne(e) { const [t, n] = e.split(W); return { namespace: t, reference: n } } function Ce(e) { const { namespace: t, reference: n } = e; return [t, n].join(W) } function re(e) { const [t, n, r] = e.split(W); return { namespace: t, reference: n, address: r } } function $e(e) { const { namespace: t, reference: n, address: r } = e; return [t, n, r].join(W) } function oe(e, t) { const n = []; return e.forEach(r => { const o = t(r); n.includes(o) || n.push(o) }), n } function je(e) { const { address: t } = re(e); return t } function _e(e) { const { namespace: t, reference: n } = re(e); return Ce({ namespace: t, reference: n }) } function cn(e, t) { const { namespace: n, reference: r } = ne(t); return $e({ namespace: n, reference: r, address: e }) } function un(e) { return oe(e, je) } function Ue(e) { return oe(e, _e) } function ln(e, t = []) { const n = []; return Object.keys(e).forEach(r => { if (t.length && !t.includes(r)) return; const o = e[r]; n.push(...o.accounts) }), n } function dn(e, t = []) { const n = []; return Object.keys(e).forEach(r => { if (t.length && !t.includes(r)) return; const o = e[r]; n.push(...Ue(o.accounts)) }), n } function pn(e, t = []) { const n = []; return Object.keys(e).forEach(r => { if (t.length && !t.includes(r)) return; const o = e[r]; n.push(...z(r, o)) }), n } function z(e, t) { return e.includes(":") ? [e] : t.chains || [] } var fn = Object.defineProperty, De = Object.getOwnPropertySymbols, mn = Object.prototype.hasOwnProperty, gn = Object.prototype.propertyIsEnumerable, Ve = (e, t, n) => t in e ? fn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ke = (e, t) => { for (var n in t || (t = {})) mn.call(t, n) && Ve(e, n, t[n]); if (De) for (var n of De(t)) gn.call(t, n) && Ve(e, n, t[n]); return e }; const xe = "ReactNative", y = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Y = " ", hn = ":", Me = "/", se = 2, yn = 1e3, Fe = "js"; function ie() { return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" } function D() { return !P.getDocument() && !!P.getNavigator() && navigator.product === xe } function M() { return !ie() && !!P.getNavigator() && !!P.getDocument() } function C() { return D() ? y.reactNative : ie() ? y.node : M() ? y.browser : y.unknown } function vn() { var e; try { return D() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0 } catch { return } } function Le(e, t) { let n = J.parse(e); return n = ke(ke({}, n), t), e = J.stringify(n), e } function En() { return Xt.getWindowMetadata() || { name: "", description: "", url: "", icons: [""] } } function bn(e, t) { var n; const r = C(), o = { protocol: e, version: t, env: r }; return r === "browser" && (o.host = ((n = P.getLocation()) == null ? void 0 : n.host) || "unknown"), o } function Ke() { if (C() === y.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") { const { OS: n, Version: r } = global.Platform; return [n, r].join("-") } const e = Zt.detect(); if (e === null) return "unknown"; const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown"; return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-") } function qe() { var e; const t = C(); return t === y.browser ? [t, ((e = P.getLocation()) == null ? void 0 : e.host) || "unknown"].join(":") : t } function Be(e, t, n) { const r = Ke(), o = qe(); return [[e, t].join("-"), [Fe, n].join("-"), r, o].join("/") } function Nn({ protocol: e, version: t, relayUrl: n, sdkVersion: r, auth: o, projectId: s, useOnCloseEvent: i, bundleId: u }) { const l = n.split("?"), a = Be(e, t, r), d = { auth: o, ua: a, projectId: s, useOnCloseEvent: i || void 0, origin: u || void 0 }, c = Le(l[1] || "", d); return l[0] + "?" + c } function On(e) { let t = (e.match(/^[^:]+(?=:\/\/)/gi) || [])[0]; const n = typeof t < "u" ? e.split("://")[1] : e; return t = t === "wss" ? "https" : "http", [t, n].join("://") } function Sn(e, t, n) { if (!e[t] || typeof e[t] !== n) throw new Error(`Missing or invalid "${t}" param`) } function He(e, t = se) { return Je(e.split(Me), t) } function wn(e) { return He(e).join(Y) } function w(e, t) { return e.filter(n => t.includes(n)).length === e.length } function Je(e, t = se) { return e.slice(Math.max(e.length - t, 0)) } function Rn(e) { return Object.fromEntries(e.entries()) } function Tn(e) { return new Map(Object.entries(e)) } function An(e, t) { const n = {}; return Object.keys(e).forEach(r => { n[r] = t(e[r]) }), n } const In = e => e; function We(e) { return e.trim().replace(/^\w/, t => t.toUpperCase()) } function Pn(e) { return e.split(Y).map(t => We(t)).join(Y) } function Cn(e = U.FIVE_MINUTES, t) { const n = U.toMiliseconds(e || U.FIVE_MINUTES); let r, o, s; return { resolve: i => { s && r && (clearTimeout(s), r(i)) }, reject: i => { s && o && (clearTimeout(s), o(i)) }, done: () => new Promise((i, u) => { s = setTimeout(() => { u(new Error(t)) }, n), r = i, o = u }) } } function $n(e, t, n) { return new Promise(async (r, o) => { const s = setTimeout(() => o(new Error(n)), t); try { const i = await e; r(i) } catch (i) { o(i) } clearTimeout(s) }) } function ae(e, t) { if (typeof t == "string" && t.startsWith(`${e}:`)) return t; if (e.toLowerCase() === "topic") { if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic'); return `topic:${t}` } else if (e.toLowerCase() === "id") { if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id'); return `id:${t}` } throw new Error(`Unknown expirer target type: ${e}`) } function jn(e) { return ae("topic", e) } function _n(e) { return ae("id", e) } function Un(e) { const [t, n] = e.split(":"), r = { id: void 0, topic: void 0 }; if (t === "topic" && typeof n == "string") r.topic = n; else if (t === "id" && Number.isInteger(Number(n))) r.id = Number(n); else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`); return r } function Dn(e, t) { return U.fromMiliseconds((t || Date.now()) + U.toMiliseconds(e)) } function Vn(e) { return Date.now() >= U.toMiliseconds(e) } function kn(e, t) { return `${e}${t ? `:${t}` : ""}` } function O(e = [], t = []) { return [...uniq([...e, ...t])] } async function xn({ id: e, topic: t, wcDeepLink: n }) { var r; try { if (!n) return; const o = typeof n == "string" ? JSON.parse(n) : n, s = o?.href; if (typeof s != "string") return; const i = ze(s, e, t), u = C(); if (u === y.browser) { if (!((r = P.getDocument()) != null && r.hasFocus())) { console.warn("Document does not have focus, skipping deeplink."); return } i.startsWith("https://") || i.startsWith("http://") ? window.open(i, "_blank", "noreferrer noopener") : window.open(i, Ye() ? "_blank" : "_self", "noreferrer noopener") } else u === y.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i) } catch (o) { console.error(o) } } function ze(e, t, n) { const r = `requestId=${t}&sessionTopic=${n}`; e.endsWith("/") && (e = e.slice(0, -1)); let o = `${e}`; if (e.startsWith("https://t.me")) { const s = e.includes("?") ? "&startapp=" : "?startapp="; o = `${o}${s}${Ge(r, !0)}` } else o = `${o}/wc?${r}`; return o } async function Mn(e, t) { let n = ""; try { if (M() && (n = localStorage.getItem(t), n)) return n; n = await e.getItem(t) } catch (r) { console.error(r) } return n } function ce(e, t) { return e.filter(n => t.includes(n)) } function Fn(e, t) { if (!e.includes(t)) return null; const n = e.split(/([&,?,=])/), r = n.indexOf(t); return n[r + 2] } function Ln() { return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, e => { const t = Math.random() * 16 | 0; return (e === "x" ? t : t & 3 | 8).toString(16) }) } function Kn() { return typeof process < "u" && process.env.IS_VITEST === "true" } function Ye() { return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto) } function Ge(e, t = !1) { const n = Buffer.from(e).toString("base64"); return t ? n.replace(/[=]/g, "") : n } function ue(e) { return Buffer.from(e, "base64").toString("utf-8") } const qn = "https://rpc.walletconnect.org/v1"; async function Qe(e, t, n, r, o, s) { switch (n.t) { case "eip191": return Ze(e, t, n.s); case "eip1271": return await Xe(e, t, n.s, r, o, s); default: throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`) } } function Ze(e, t, n) { return tn.recoverAddress(Te.hashMessage(t), n).toLowerCase() === e.toLowerCase() } async function Xe(e, t, n, r, o, s) { const i = ne(r); if (!i.namespace || !i.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`); try { const u = "0x1626ba7e", l = "0000000000000000000000000000000000000000000000000000000000000040", a = "0000000000000000000000000000000000000000000000000000000000000041", d = n.substring(2), c = Te.hashMessage(t).substring(2), f = u + c + l + a + d, h = await fetch(`${s || qn}/?chainId=${r}&projectId=${o}`, { method: "POST", body: JSON.stringify({ id: Bn(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: f }, "latest"] }) }), { result: m } = await h.json(); return m ? m.slice(0, u.length).toLowerCase() === u.toLowerCase() : !1 } catch (u) { return console.error("isValidEip1271Signature: ", u), !1 } } function Bn() { return Date.now() + Math.floor(Math.random() * 1e3) } var Hn = Object.defineProperty, Jn = Object.defineProperties, Wn = Object.getOwnPropertyDescriptors, et = Object.getOwnPropertySymbols, zn = Object.prototype.hasOwnProperty, Yn = Object.prototype.propertyIsEnumerable, tt = (e, t, n) => t in e ? Hn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, le = (e, t) => { for (var n in t || (t = {})) zn.call(t, n) && tt(e, n, t[n]); if (et) for (var n of et(t)) Yn.call(t, n) && tt(e, n, t[n]); return e }, nt = (e, t) => Jn(e, Wn(t)); const Gn = "did:pkh:", G = e => e?.split(":"), rt = e => { const t = e && G(e); if (t) return e.includes(Gn) ? t[3] : t[1] }, ot = e => { const t = e && G(e); if (t) return t[2] + ":" + t[3] }, de = e => { const t = e && G(e); if (t) return t.pop() }; async function Qn(e) { const { cacao: t, projectId: n } = e, { s: r, p: o } = t, s = st(o, o.iss), i = de(o.iss); return await Qe(i, s, r, ot(o.iss), n) } const st = (e, t) => {
+  const n = `${e.domain} wants you to sign in with your Ethereum account:`, r = de(t); if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message"); let o = e.statement || void 0; const s = `URI: ${e.aud || e.uri}`, i = `Version: ${e.version}`, u = `Chain ID: ${rt(t)}`, l = `Nonce: ${e.nonce}`, a = `Issued At: ${e.iat}`, d = e.exp ? `Expiration Time: ${e.exp}` : void 0, c = e.nbf ? `Not Before: ${e.nbf}` : void 0, f = e.requestId ? `Request ID: ${e.requestId}` : void 0, h = e.resources ? `Resources:${e.resources.map(g => `
+- ${g}`).join("")}` : void 0, m = Z(e.resources); if (m) { const g = R(m); o = me(o, g) } return [n, r, "", o, "", s, i, u, l, a, d, c, f, h].filter(g => g != null).join(`
+`)
+}; function Zn(e, t, n) { return n.includes("did:pkh:") || (n = `did:pkh:${n}`), { h: { t: "caip122" }, p: { iss: n, domain: e.domain, aud: e.aud, version: e.version, nonce: e.nonce, iat: e.iat, statement: e.statement, requestId: e.requestId, resources: e.resources, nbf: e.nbf, exp: e.exp }, s: t } } function Xn(e) { var t; const { authPayload: n, chains: r, methods: o } = e, s = n.statement || ""; if (!(r != null && r.length)) return n; const i = n.chains, u = ce(i, r); if (!(u != null && u.length)) throw new Error("No supported chains"); const l = it(n.resources); if (!l) return n; N(l); const a = at(l, "eip155"); let d = n?.resources || []; if (a != null && a.length) { const c = ct(a), f = ce(c, o); if (!(f != null && f.length)) throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(c)}, supported: ${JSON.stringify(o)}`); const h = pe("request", f, { chains: u }), m = pt(l, "eip155", h); d = ((t = n?.resources) == null ? void 0 : t.slice(0, -1)) || [], d.push(Q(m)) } return nt(le({}, n), { statement: mt(s, Z(d)), chains: u, resources: n != null && n.resources || d.length > 0 ? d : void 0 }) } function it(e) { const t = Z(e); if (t && fe(t)) return R(t) } function er(e, t) { var n; return (n = e?.att) == null ? void 0 : n.hasOwnProperty(t) } function at(e, t) { var n, r; return (n = e?.att) != null && n[t] ? Object.keys((r = e?.att) == null ? void 0 : r[t]) : [] } function tr(e) { return e?.map(t => Object.keys(t)) || [] } function ct(e) { return e?.map(t => { var n; return (n = t.split("/")) == null ? void 0 : n[1] }) || [] } function ut(e) { return Buffer.from(JSON.stringify(e)).toString("base64") } function lt(e) { return JSON.parse(Buffer.from(e, "base64").toString("utf-8")) } function N(e) { if (!e) throw new Error("No recap provided, value is undefined"); if (!e.att) throw new Error("No `att` property found"); const t = Object.keys(e.att); if (!(t != null && t.length)) throw new Error("No resources found in `att` property"); t.forEach(n => { const r = e.att[n]; if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n}`); if (typeof r != "object") throw new Error(`Resource must be an object: ${n}`); if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${n}`); Object.keys(r).forEach(o => { const s = r[o]; if (!Array.isArray(s)) throw new Error(`Ability limits ${o} must be an array of objects, found: ${s}`); if (!s.length) throw new Error(`Value of ${o} is empty array, must be an array with objects`); s.forEach(i => { if (typeof i != "object") throw new Error(`Ability limits (${o}) must be an array of objects, found: ${i}`) }) }) }) } function dt(e, t, n, r = {}) { return n?.sort((o, s) => o.localeCompare(s)), { att: { [e]: pe(t, n, r) } } } function pt(e, t, n) { var r; return e.att[t] = le({}, n), ((r = Object.keys(e.att)) == null ? void 0 : r.sort((o, s) => o.localeCompare(s))).reduce((o, s) => (o.att[s] = e.att[s], o), { att: {} }) } function pe(e, t, n = {}) { t = t?.sort((o, s) => o.localeCompare(s)); const r = t.map(o => ({ [`${e}/${o}`]: [n] })); return Object.assign({}, ...r) } function Q(e) { return N(e), `urn:recap:${ut(e).replace(/=/g, "")}` } function R(e) { const t = lt(e.replace("urn:recap:", "")); return N(t), t } function nr(e, t, n) { const r = dt(e, t, n); return Q(r) } function fe(e) { return e && e.includes("urn:recap:") } function rr(e, t) { const n = R(e), r = R(t), o = ft(n, r); return Q(o) } function ft(e, t) { N(e), N(t); const n = Object.keys(e.att).concat(Object.keys(t.att)).sort((o, s) => o.localeCompare(s)), r = { att: {} }; return n.forEach(o => { var s, i; Object.keys(((s = e.att) == null ? void 0 : s[o]) || {}).concat(Object.keys(((i = t.att) == null ? void 0 : i[o]) || {})).sort((u, l) => u.localeCompare(l)).forEach(u => { var l, a; r.att[o] = nt(le({}, r.att[o]), { [u]: ((l = e.att[o]) == null ? void 0 : l[u]) || ((a = t.att[o]) == null ? void 0 : a[u]) }) }) }), r } function me(e = "", t) { N(t); const n = "I further authorize the stated URI to perform the following actions on my behalf: "; if (e.includes(n)) return e; const r = []; let o = 0; Object.keys(t.att).forEach(u => { const l = Object.keys(t.att[u]).map(c => ({ ability: c.split("/")[0], action: c.split("/")[1] })); l.sort((c, f) => c.action.localeCompare(f.action)); const a = {}; l.forEach(c => { a[c.ability] || (a[c.ability] = []), a[c.ability].push(c.action) }); const d = Object.keys(a).map(c => (o++, `(${o}) '${c}': '${a[c].join("', '")}' for '${u}'.`)); r.push(d.join(", ").replace(".,", ".")) }); const s = r.join(" "), i = `${n}${s}`; return `${e ? e + " " : ""}${i}` } function or(e) { var t; const n = R(e); N(n); const r = (t = n.att) == null ? void 0 : t.eip155; return r ? Object.keys(r).map(o => o.split("/")[1]) : [] } function sr(e) { const t = R(e); N(t); const n = []; return Object.values(t.att).forEach(r => { Object.values(r).forEach(o => { var s; (s = o?.[0]) != null && s.chains && n.push(o[0].chains) }) }), [...uniq(n.flat())] } function mt(e, t) { if (!t) return e; const n = R(t); return N(n), me(e, n) } function Z(e) { if (!e) return; const t = e?.[e.length - 1]; return fe(t) ? t : void 0 } const ge = "base10", v = "base16", he = "base64pad", ir = "base64url", V = "utf8", ye = 0, k = 1, F = 2, ar = 0, gt = 1, L = 12, ve = 32; function cr() { const e = Pe.generateKeyPair(); return { privateKey: p.toString(e.secretKey, v), publicKey: p.toString(e.publicKey, v) } } function ur() { const e = B.randomBytes(ve); return p.toString(e, v) } function lr(e, t) { const n = Pe.sharedKey(p.fromString(e, v), p.fromString(t, v), !0), r = new nn.HKDF(H.SHA256, n).expand(ve); return p.toString(r, v) } function dr(e) { const t = H.hash(p.fromString(e, v)); return p.toString(t, v) } function pr(e) { const t = H.hash(p.fromString(e, V)); return p.toString(t, v) } function Ee(e) { return p.fromString(`${e}`, ge) } function $(e) { return Number(p.toString(e, ge)) } function fr(e) { const t = Ee(typeof e.type < "u" ? e.type : ye); if ($(t) === k && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope"); const n = typeof e.senderPublicKey < "u" ? p.fromString(e.senderPublicKey, v) : void 0, r = typeof e.iv < "u" ? p.fromString(e.iv, v) : B.randomBytes(L), o = new Ae.ChaCha20Poly1305(p.fromString(e.symKey, v)).seal(r, p.fromString(e.message, V)); return be({ type: t, sealed: o, iv: r, senderPublicKey: n, encoding: e.encoding }) } function mr(e, t) { const n = Ee(F), r = B.randomBytes(L), o = p.fromString(e, V); return be({ type: n, sealed: o, iv: r, encoding: t }) } function gr(e) { const t = new Ae.ChaCha20Poly1305(p.fromString(e.symKey, v)), { sealed: n, iv: r } = X({ encoded: e.encoded, encoding: e?.encoding }), o = t.open(r, n); if (o === null) throw new Error("Failed to decrypt"); return p.toString(o, V) } function hr(e, t) { const { sealed: n } = X({ encoded: e, encoding: t }); return p.toString(n, V) } function be(e) { const { encoding: t = he } = e; if ($(e.type) === F) return p.toString(p.concat([e.type, e.sealed]), t); if ($(e.type) === k) { if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope"); return p.toString(p.concat([e.type, e.senderPublicKey, e.iv, e.sealed]), t) } return p.toString(p.concat([e.type, e.iv, e.sealed]), t) } function X(e) { const { encoded: t, encoding: n = he } = e, r = p.fromString(t, n), o = r.slice(ar, gt), s = gt; if ($(o) === k) { const a = s + ve, d = a + L, c = r.slice(s, a), f = r.slice(a, d), h = r.slice(d); return { type: o, sealed: h, iv: f, senderPublicKey: c } } if ($(o) === F) { const a = r.slice(s), d = B.randomBytes(L); return { type: o, sealed: a, iv: d } } const i = s + L, u = r.slice(s, i), l = r.slice(i); return { type: o, sealed: l, iv: u } } function yr(e, t) { const n = X({ encoded: e, encoding: t?.encoding }); return ht({ type: $(n.type), senderPublicKey: typeof n.senderPublicKey < "u" ? p.toString(n.senderPublicKey, v) : void 0, receiverPublicKey: t?.receiverPublicKey }) } function ht(e) { const t = e?.type || ye; if (t === k) { if (typeof e?.senderPublicKey > "u") throw new Error("missing sender public key"); if (typeof e?.receiverPublicKey > "u") throw new Error("missing receiver public key") } return { type: t, senderPublicKey: e?.senderPublicKey, receiverPublicKey: e?.receiverPublicKey } } function vr(e) { return e.type === k && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string" } function Er(e) { return e.type === F } function yt(e) { return new on.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex") } function br(e) { let t = e.replace(/-/g, "+").replace(/_/g, "/"); const n = t.length % 4; return n > 0 && (t += "=".repeat(4 - n)), t } function Nr(e) { return Buffer.from(br(e), "base64") } function Or(e, t) { const [n, r, o] = e.split("."), s = Nr(o); if (s.length !== 64) throw new Error("Invalid signature length"); const i = s.slice(0, 32).toString("hex"), u = s.slice(32, 64).toString("hex"), l = `${n}.${r}`, a = new H.SHA256().update(Buffer.from(l)).digest(), d = yt(t), c = Buffer.from(a).toString("hex"); if (!d.verify(c, { r: i, s: u })) throw new Error("Invalid signature"); return sn.decodeJWT(e).payload } const vt = "irn"; function Sr(e) { return e?.relay || { protocol: vt } } function wr(e) { const t = an.RELAY_JSONRPC[e]; if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`); return t } var Rr = Object.defineProperty, Tr = Object.defineProperties, Ar = Object.getOwnPropertyDescriptors, Et = Object.getOwnPropertySymbols, Ir = Object.prototype.hasOwnProperty, Pr = Object.prototype.propertyIsEnumerable, bt = (e, t, n) => t in e ? Rr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Nt = (e, t) => { for (var n in t || (t = {})) Ir.call(t, n) && bt(e, n, t[n]); if (Et) for (var n of Et(t)) Pr.call(t, n) && bt(e, n, t[n]); return e }, Cr = (e, t) => Tr(e, Ar(t)); function Ot(e, t = "-") { const n = {}, r = "relay" + t; return Object.keys(e).forEach(o => { if (o.startsWith(r)) { const s = o.replace(r, ""), i = e[o]; n[s] = i } }), n } function $r(e) { if (!e.includes("wc:")) { const l = ue(e); l != null && l.includes("wc:") && (e = l) } e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e; const t = e.indexOf(":"), n = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, t), o = e.substring(t + 1, n).split("@"), s = typeof n < "u" ? e.substring(n) : "", i = J.parse(s), u = typeof i.methods == "string" ? i.methods.split(",") : void 0; return { protocol: r, topic: St(o[0]), version: parseInt(o[1], 10), symKey: i.symKey, relay: Ot(i), methods: u, expiryTimestamp: i.expiryTimestamp ? parseInt(i.expiryTimestamp, 10) : void 0 } } function St(e) { return e.startsWith("//") ? e.substring(2) : e } function wt(e, t = "-") { const n = "relay", r = {}; return Object.keys(e).forEach(o => { const s = n + t + o; e[o] && (r[s] = e[o]) }), r } function jr(e) { return `${e.protocol}:${e.topic}@${e.version}?` + J.stringify(Nt(Cr(Nt({ symKey: e.symKey }, wt(e.relay)), { expiryTimestamp: e.expiryTimestamp }), e.methods ? { methods: e.methods.join(",") } : {})) } function _r(e, t, n) { return `${e}?wc_ev=${n}&topic=${t}` } var Ur = Object.defineProperty, Dr = Object.defineProperties, Vr = Object.getOwnPropertyDescriptors, Rt = Object.getOwnPropertySymbols, kr = Object.prototype.hasOwnProperty, xr = Object.prototype.propertyIsEnumerable, Tt = (e, t, n) => t in e ? Ur(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Mr = (e, t) => { for (var n in t || (t = {})) kr.call(t, n) && Tt(e, n, t[n]); if (Rt) for (var n of Rt(t)) xr.call(t, n) && Tt(e, n, t[n]); return e }, Fr = (e, t) => Dr(e, Vr(t)); function j(e) { const t = []; return e.forEach(n => { const [r, o] = n.split(":"); t.push(`${r}:${o}`) }), t } function At(e) { const t = []; return Object.values(e).forEach(n => { t.push(...j(n.accounts)) }), t } function It(e, t) { const n = []; return Object.values(e).forEach(r => { j(r.accounts).includes(t) && n.push(...r.methods) }), n } function Pt(e, t) { const n = []; return Object.values(e).forEach(r => { j(r.accounts).includes(t) && n.push(...r.events) }), n } function Lr(e, t) { const n = Ft(e, t); if (n) throw new Error(n.message); const r = {}; for (const [o, s] of Object.entries(e)) r[o] = { methods: s.methods, events: s.events, chains: s.accounts.map(i => `${i.split(":")[0]}:${i.split(":")[1]}`) }; return r } function Kr(e) { const { proposal: { requiredNamespaces: t, optionalNamespaces: n = {} }, supportedNamespaces: r } = e, o = Oe(t), s = Oe(n), i = {}; Object.keys(r).forEach(a => { const d = r[a].chains, c = r[a].methods, f = r[a].events, h = r[a].accounts; d.forEach(m => { if (!h.some(g => g.includes(m))) throw new Error(`No accounts provided for chain ${m} in namespace ${a}`) }), i[a] = { chains: d, methods: c, events: f, accounts: h } }); const u = Kt(t, i, "approve()"); if (u) throw new Error(u.message); const l = {}; return !Object.keys(t).length && !Object.keys(n).length ? i : (Object.keys(o).forEach(a => { const d = r[a].chains.filter(m => { var g, b; return (b = (g = o[a]) == null ? void 0 : g.chains) == null ? void 0 : b.includes(m) }), c = r[a].methods.filter(m => { var g, b; return (b = (g = o[a]) == null ? void 0 : g.methods) == null ? void 0 : b.includes(m) }), f = r[a].events.filter(m => { var g, b; return (b = (g = o[a]) == null ? void 0 : g.events) == null ? void 0 : b.includes(m) }), h = d.map(m => r[a].accounts.filter(g => g.includes(`${m}:`))).flat(); l[a] = { chains: d, methods: c, events: f, accounts: h } }), Object.keys(s).forEach(a => { var d, c, f, h, m, g; if (!r[a]) return; const b = (c = (d = s[a]) == null ? void 0 : d.chains) == null ? void 0 : c.filter(A => r[a].chains.includes(A)), Yt = r[a].methods.filter(A => { var I, x; return (x = (I = s[a]) == null ? void 0 : I.methods) == null ? void 0 : x.includes(A) }), Gt = r[a].events.filter(A => { var I, x; return (x = (I = s[a]) == null ? void 0 : I.events) == null ? void 0 : x.includes(A) }), Qt = b?.map(A => r[a].accounts.filter(I => I.includes(`${A}:`))).flat(); l[a] = { chains: O((f = l[a]) == null ? void 0 : f.chains, b), methods: O((h = l[a]) == null ? void 0 : h.methods, Yt), events: O((m = l[a]) == null ? void 0 : m.events, Gt), accounts: O((g = l[a]) == null ? void 0 : g.accounts, Qt) } }), l) } function Ne(e) { return e.includes(":") } function Ct(e) { return Ne(e) ? e.split(":")[0] : e } function Oe(e) { var t, n, r; const o = {}; if (!ee(e)) return o; for (const [s, i] of Object.entries(e)) { const u = Ne(s) ? [s] : i.chains, l = i.methods || [], a = i.events || [], d = Ct(s); o[d] = Fr(Mr({}, o[d]), { chains: O(u, (t = o[d]) == null ? void 0 : t.chains), methods: O(l, (n = o[d]) == null ? void 0 : n.methods), events: O(a, (r = o[d]) == null ? void 0 : r.events) }) } return o } function $t(e) { const t = {}; return e?.forEach(n => { const [r, o] = n.split(":"); t[r] || (t[r] = { accounts: [], chains: [], events: [] }), t[r].accounts.push(n), t[r].chains.push(`${r}:${o}`) }), t } function qr(e, t) { t = t.map(r => r.replace("did:pkh:", "")); const n = $t(t); for (const [r, o] of Object.entries(n)) o.methods ? o.methods = O(o.methods, e) : o.methods = e, o.events = ["chainChanged", "accountsChanged"]; return n } const jt = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, _t = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } }; function S(e, t) { const { message: n, code: r } = _t[e]; return { message: t ? `${n} ${t}` : n, code: r } } function _(e, t) { const { message: n, code: r } = jt[e]; return { message: t ? `${n} ${t}` : n, code: r } } function K(e, t) { return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1 } function ee(e) { return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length } function T(e) { return typeof e > "u" } function E(e, t) { return t && T(e) ? !0 : typeof e == "string" && !!e.trim().length } function te(e, t) { return t && T(e) ? !0 : typeof e == "number" && !isNaN(e) } function Br(e, t) { const { requiredNamespaces: n } = t, r = Object.keys(e.namespaces), o = Object.keys(n); let s = !0; return w(o, r) ? (r.forEach(i => { const { accounts: u, methods: l, events: a } = e.namespaces[i], d = j(u), c = n[i]; (!w(z(i, c), d) || !w(c.methods, l) || !w(c.events, a)) && (s = !1) }), s) : !1 } function q(e) { return E(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1 } function Ut(e) { if (E(e, !1) && e.includes(":")) { const t = e.split(":"); if (t.length === 3) { const n = t[0] + ":" + t[1]; return !!t[2] && q(n) } } return !1 } function Hr(e) { function t(n) { try { return typeof new URL(n) < "u" } catch { return !1 } } try { if (E(e, !1)) { if (t(e)) return !0; const n = ue(e); return t(n) } } catch { } return !1 } function Jr(e) { var t; return (t = e?.proposer) == null ? void 0 : t.publicKey } function Wr(e) { return e?.topic } function zr(e, t) { let n = null; return E(e?.publicKey, !1) || (n = S("MISSING_OR_INVALID", `${t} controller public key should be a string`)), n } function Se(e) { let t = !0; return K(e) ? e.length && (t = e.every(n => E(n, !1))) : t = !1, t } function Dt(e, t, n) { let r = null; return K(t) && t.length ? t.forEach(o => { r || q(o) || (r = _("UNSUPPORTED_CHAINS", `${n}, chain ${o} should be a string and conform to "namespace:chainId" format`)) }) : q(e) || (r = _("UNSUPPORTED_CHAINS", `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r } function Vt(e, t, n) { let r = null; return Object.entries(e).forEach(([o, s]) => { if (r) return; const i = Dt(o, z(o, s), `${t} ${n}`); i && (r = i) }), r } function kt(e, t) { let n = null; return K(e) ? e.forEach(r => { n || Ut(r) || (n = _("UNSUPPORTED_ACCOUNTS", `${t}, account ${r} should be a string and conform to "namespace:chainId:address" format`)) }) : n = _("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n } function xt(e, t) { let n = null; return Object.values(e).forEach(r => { if (n) return; const o = kt(r?.accounts, `${t} namespace`); o && (n = o) }), n } function Mt(e, t) { let n = null; return Se(e?.methods) ? Se(e?.events) || (n = _("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n = _("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), n } function we(e, t) { let n = null; return Object.values(e).forEach(r => { if (n) return; const o = Mt(r, `${t}, namespace`); o && (n = o) }), n } function Yr(e, t, n) { let r = null; if (e && ee(e)) { const o = we(e, t); o && (r = o); const s = Vt(e, t, n); s && (r = s) } else r = S("MISSING_OR_INVALID", `${t}, ${n} should be an object with data`); return r } function Ft(e, t) { let n = null; if (e && ee(e)) { const r = we(e, t); r && (n = r); const o = xt(e, t); o && (n = o) } else n = S("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`); return n } function Lt(e) { return E(e.protocol, !0) } function Gr(e, t) { let n = !1; return t && !e ? n = !0 : e && K(e) && e.length && e.forEach(r => { n = Lt(r) }), n } function Qr(e) { return typeof e == "number" } function Zr(e) { return typeof e < "u" && typeof e !== null } function Xr(e) { return !(!e || typeof e != "object" || !e.code || !te(e.code, !1) || !e.message || !E(e.message, !1)) } function eo(e) { return !(T(e) || !E(e.method, !1)) } function to(e) { return !(T(e) || T(e.result) && T(e.error) || !te(e.id, !1) || !E(e.jsonrpc, !1)) } function no(e) { return !(T(e) || !E(e.name, !1)) } function ro(e, t) { return !(!q(t) || !At(e).includes(t)) } function oo(e, t, n) { return E(n, !1) ? It(e, t).includes(n) : !1 } function so(e, t, n) { return E(n, !1) ? Pt(e, t).includes(n) : !1 } function Kt(e, t, n) {
+  let r = null; const o = io(e), s = ao(t), i = Object.keys(o), u = Object.keys(s), l = qt(Object.keys(e)), a = qt(Object.keys(t)), d = l.filter(c => !a.includes(c)); return d.length && (r = S("NON_CONFORMING_NAMESPACES", `${n} namespaces keys don't satisfy requiredNamespaces.
       Required: ${d.toString()}
-      Received: ${Object.keys(t).toString()}`)),w(i,u)||(r=S("NON_CONFORMING_NAMESPACES",`${n} namespaces chains don't satisfy required namespaces.
+      Received: ${Object.keys(t).toString()}`)), w(i, u) || (r = S("NON_CONFORMING_NAMESPACES", `${n} namespaces chains don't satisfy required namespaces.
       Required: ${i.toString()}
-      Approved: ${u.toString()}`)),Object.keys(t).forEach(c=>{if(!c.includes(":")||r)return;const f=j(t[c].accounts);f.includes(c)||(r=S("NON_CONFORMING_NAMESPACES",`${n} namespaces accounts don't satisfy namespace accounts for ${c}
+      Approved: ${u.toString()}`)), Object.keys(t).forEach(c => {
+    if (!c.includes(":") || r) return; const f = j(t[c].accounts); f.includes(c) || (r = S("NON_CONFORMING_NAMESPACES", `${n} namespaces accounts don't satisfy namespace accounts for ${c}
         Required: ${c}
-        Approved: ${f.toString()}`))}),i.forEach(c=>{r||(w(o[c].methods,s[c].methods)?w(o[c].events,s[c].events)||(r=S("NON_CONFORMING_NAMESPACES",`${n} namespaces events don't satisfy namespace events for ${c}`)):r=S("NON_CONFORMING_NAMESPACES",`${n} namespaces methods don't satisfy namespace methods for ${c}`))}),r}function io(e){const t={};return Object.keys(e).forEach(n=>{var r;n.includes(":")?t[n]=e[n]:(r=e[n].chains)==null||r.forEach(o=>{t[o]={methods:e[n].methods,events:e[n].events}})}),t}function qt(e){return[...new Set(e.map(t=>t.includes(":")?t.split(":")[0]:t))]}function ao(e){const t={};return Object.keys(e).forEach(n=>{if(n.includes(":"))t[n]=e[n];else{const r=j(e[n].accounts);r?.forEach(o=>{t[o]={accounts:e[n].accounts.filter(s=>s.includes(`${o}:`)),methods:e[n].methods,events:e[n].events}})}}),t}function co(e,t){return te(e,!1)&&e<=t.max&&e>=t.min}function uo(){const e=C();return new Promise(t=>{switch(e){case y.browser:t(Bt());break;case y.reactNative:t(Ht());break;case y.node:t(Jt());break;default:t(!0)}})}function Bt(){return M()&&navigator?.onLine}async function Ht(){if(D()&&typeof global<"u"&&global!=null&&global.NetInfo){const e=await(global==null?void 0:global.NetInfo.fetch());return e?.isConnected}return!0}function Jt(){return!0}function lo(e){switch(C()){case y.browser:Wt(e);break;case y.reactNative:zt(e);break;case y.node:break}}function Wt(e){!D()&&M()&&(window.addEventListener("online",()=>e(!0)),window.addEventListener("offline",()=>e(!1)))}function zt(e){D()&&typeof global<"u"&&global!=null&&global.NetInfo&&global?.NetInfo.addEventListener(t=>e(t?.isConnected))}const Re={};class po{static get(t){return Re[t]}static set(t,n){Re[t]=n}static delete(t){delete Re[t]}}exports.BASE10=ge,exports.BASE16=v,exports.BASE64=he,exports.BASE64URL=ir,exports.COLON=hn,exports.DEFAULT_DEPTH=se,exports.EMPTY_SPACE=Y,exports.ENV_MAP=y,exports.INTERNAL_ERRORS=_t,exports.MemoryStore=po,exports.ONE_THOUSAND=yn,exports.REACT_NATIVE_PRODUCT=xe,exports.RELAYER_DEFAULT_PROTOCOL=vt,exports.SDK_ERRORS=jt,exports.SDK_TYPE=Fe,exports.SLASH=Me,exports.TYPE_0=ye,exports.TYPE_1=k,exports.TYPE_2=F,exports.UTF8=V,exports.addResourceToRecap=pt,exports.appendToQueryString=Le,exports.assertType=Sn,exports.assignAbilityToActions=pe,exports.base64Decode=lt,exports.base64Encode=ut,exports.buildApprovedNamespaces=Kr,exports.buildAuthObject=Zn,exports.buildNamespacesFromAuth=qr,exports.buildRecapStatement=mt,exports.calcExpiry=Dn,exports.capitalize=Pn,exports.capitalizeWord=We,exports.createDelayedPromise=Cn,exports.createEncodedRecap=nr,exports.createExpiringPromise=$n,exports.createRecap=dt,exports.decodeRecap=R,exports.decodeTypeByte=$,exports.decodeTypeTwoEnvelope=hr,exports.decrypt=gr,exports.deriveSymKey=lr,exports.deserialize=X,exports.encodeRecap=Q,exports.encodeTypeByte=Ee,exports.encodeTypeTwoEnvelope=mr,exports.encrypt=fr,exports.engineEvent=kn,exports.enumify=In,exports.formatAccountId=$e,exports.formatAccountWithChain=cn,exports.formatChainId=Ce,exports.formatDeeplinkUrl=ze,exports.formatExpirerTarget=ae,exports.formatIdTarget=_n,exports.formatMessage=st,exports.formatMessageContext=wn,exports.formatRelayParams=wt,exports.formatRelayRpcUrl=Nn,exports.formatStatementFromRecap=me,exports.formatTopicTarget=jn,exports.formatUA=Be,exports.formatUri=jr,exports.fromBase64=ue,exports.generateKeyPair=cr,exports.generateRandomBytes32=ur,exports.getAccountsChains=j,exports.getAccountsFromNamespaces=ln,exports.getAddressFromAccount=je,exports.getAddressesFromAccounts=un,exports.getAppMetadata=En,exports.getBrowserOnlineStatus=Bt,exports.getBundleId=vn,exports.getChainFromAccount=_e,exports.getChainsFromAccounts=Ue,exports.getChainsFromNamespace=z,exports.getChainsFromNamespaces=dn,exports.getChainsFromRecap=sr,exports.getChainsFromRequiredNamespaces=pn,exports.getCommonValuesInArrays=ce,exports.getCryptoKeyFromKeyData=yt,exports.getDecodedRecapFromResources=it,exports.getDeepLink=Mn,exports.getDidAddress=de,exports.getDidAddressSegments=G,exports.getDidChainId=rt,exports.getEnvironment=C,exports.getHttpUrl=On,exports.getInternalError=S,exports.getJavascriptID=qe,exports.getJavascriptOS=Ke,exports.getLastItems=Je,exports.getLinkModeURL=_r,exports.getMethodsFromRecap=or,exports.getNamespacedDidChainId=ot,exports.getNamespacesChains=At,exports.getNamespacesEventsForChainId=Pt,exports.getNamespacesFromAccounts=$t,exports.getNamespacesMethodsForChainId=It,exports.getNodeOnlineStatus=Jt,exports.getReCapActions=ct,exports.getReactNativeOnlineStatus=Ht,exports.getRecapAbilitiesFromResource=tr,exports.getRecapFromResources=Z,exports.getRecapResource=at,exports.getRelayClientMetadata=bn,exports.getRelayProtocolApi=wr,exports.getRelayProtocolName=Sr,exports.getRequiredNamespacesFromNamespaces=Lr,exports.getSdkError=_,exports.getSearchParamFromURL=Fn,exports.getUniqueValues=oe,exports.handleDeeplinkRedirect=xn,exports.hasOverlap=w,exports.hashKey=dr,exports.hashMessage=pr,exports.isBrowser=M,exports.isCaipNamespace=Ne,exports.isConformingNamespaces=Kt,exports.isExpired=Vn,exports.isNode=ie,exports.isOnline=uo,exports.isProposalStruct=Jr,exports.isReactNative=D,exports.isRecap=fe,exports.isSessionCompatible=Br,exports.isSessionStruct=Wr,exports.isTelegram=Ye,exports.isTestRun=Kn,exports.isTypeOneEnvelope=vr,exports.isTypeTwoEnvelope=Er,exports.isUndefined=T,exports.isValidAccountId=Ut,exports.isValidAccounts=kt,exports.isValidActions=Mt,exports.isValidArray=K,exports.isValidChainId=q,exports.isValidChains=Dt,exports.isValidController=zr,exports.isValidEip1271Signature=Xe,exports.isValidEip191Signature=Ze,exports.isValidErrorReason=Xr,exports.isValidEvent=no,exports.isValidId=Qr,exports.isValidNamespaceAccounts=xt,exports.isValidNamespaceActions=we,exports.isValidNamespaceChains=Vt,exports.isValidNamespaceMethodsOrEvents=Se,exports.isValidNamespaces=Ft,exports.isValidNamespacesChainId=ro,exports.isValidNamespacesEvent=so,exports.isValidNamespacesRequest=oo,exports.isValidNumber=te,exports.isValidObject=ee,exports.isValidParams=Zr,exports.isValidRecap=N,exports.isValidRelay=Lt,exports.isValidRelays=Gr,exports.isValidRequest=eo,exports.isValidRequestExpiry=co,exports.isValidRequiredNamespaces=Yr,exports.isValidResponse=to,exports.isValidString=E,exports.isValidUrl=Hr,exports.mapEntries=An,exports.mapToObj=Rn,exports.mergeArrays=O,exports.mergeEncodedRecaps=rr,exports.mergeRecaps=ft,exports.normalizeNamespaces=Oe,exports.objToMap=Tn,exports.parseAccountId=re,exports.parseChainId=ne,exports.parseContextNames=He,exports.parseExpirerTarget=Un,exports.parseNamespaceKey=Ct,exports.parseRelayParams=Ot,exports.parseTopic=St,exports.parseUri=$r,exports.populateAuthPayload=Xn,exports.recapHasResource=er,exports.serialize=be,exports.subscribeToBrowserNetworkChange=Wt,exports.subscribeToNetworkChange=lo,exports.subscribeToReactNativeNetworkChange=zt,exports.toBase64=Ge,exports.uuidv4=Ln,exports.validateDecoding=yr,exports.validateEncoding=ht,exports.validateSignedCacao=Qn,exports.verifyP256Jwt=Or,exports.verifySignature=Qe;
+        Approved: ${f.toString()}`))
+  }), i.forEach(c => { r || (w(o[c].methods, s[c].methods) ? w(o[c].events, s[c].events) || (r = S("NON_CONFORMING_NAMESPACES", `${n} namespaces events don't satisfy namespace events for ${c}`)) : r = S("NON_CONFORMING_NAMESPACES", `${n} namespaces methods don't satisfy namespace methods for ${c}`)) }), r
+} function io(e) { const t = {}; return Object.keys(e).forEach(n => { var r; n.includes(":") ? t[n] = e[n] : (r = e[n].chains) == null || r.forEach(o => { t[o] = { methods: e[n].methods, events: e[n].events } }) }), t } function qt(e) { return [...uniq(e.map(t => t.includes(":") ? t.split(":")[0] : t))] } function ao(e) { const t = {}; return Object.keys(e).forEach(n => { if (n.includes(":")) t[n] = e[n]; else { const r = j(e[n].accounts); r?.forEach(o => { t[o] = { accounts: e[n].accounts.filter(s => s.includes(`${o}:`)), methods: e[n].methods, events: e[n].events } }) } }), t } function co(e, t) { return te(e, !1) && e <= t.max && e >= t.min } function uo() { const e = C(); return new Promise(t => { switch (e) { case y.browser: t(Bt()); break; case y.reactNative: t(Ht()); break; case y.node: t(Jt()); break; default: t(!0) } }) } function Bt() { return M() && navigator?.onLine } async function Ht() { if (D() && typeof global < "u" && global != null && global.NetInfo) { const e = await (global == null ? void 0 : global.NetInfo.fetch()); return e?.isConnected } return !0 } function Jt() { return !0 } function lo(e) { switch (C()) { case y.browser: Wt(e); break; case y.reactNative: zt(e); break; case y.node: break } } function Wt(e) { !D() && M() && (window.addEventListener("online", () => e(!0)), window.addEventListener("offline", () => e(!1))) } function zt(e) { D() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener(t => e(t?.isConnected)) } const Re = {}; class po { static get(t) { return Re[t] } static set(t, n) { Re[t] = n } static delete(t) { delete Re[t] } } exports.BASE10 = ge, exports.BASE16 = v, exports.BASE64 = he, exports.BASE64URL = ir, exports.COLON = hn, exports.DEFAULT_DEPTH = se, exports.EMPTY_SPACE = Y, exports.ENV_MAP = y, exports.INTERNAL_ERRORS = _t, exports.MemoryStore = po, exports.ONE_THOUSAND = yn, exports.REACT_NATIVE_PRODUCT = xe, exports.RELAYER_DEFAULT_PROTOCOL = vt, exports.SDK_ERRORS = jt, exports.SDK_TYPE = Fe, exports.SLASH = Me, exports.TYPE_0 = ye, exports.TYPE_1 = k, exports.TYPE_2 = F, exports.UTF8 = V, exports.addResourceToRecap = pt, exports.appendToQueryString = Le, exports.assertType = Sn, exports.assignAbilityToActions = pe, exports.base64Decode = lt, exports.base64Encode = ut, exports.buildApprovedNamespaces = Kr, exports.buildAuthObject = Zn, exports.buildNamespacesFromAuth = qr, exports.buildRecapStatement = mt, exports.calcExpiry = Dn, exports.capitalize = Pn, exports.capitalizeWord = We, exports.createDelayedPromise = Cn, exports.createEncodedRecap = nr, exports.createExpiringPromise = $n, exports.createRecap = dt, exports.decodeRecap = R, exports.decodeTypeByte = $, exports.decodeTypeTwoEnvelope = hr, exports.decrypt = gr, exports.deriveSymKey = lr, exports.deserialize = X, exports.encodeRecap = Q, exports.encodeTypeByte = Ee, exports.encodeTypeTwoEnvelope = mr, exports.encrypt = fr, exports.engineEvent = kn, exports.enumify = In, exports.formatAccountId = $e, exports.formatAccountWithChain = cn, exports.formatChainId = Ce, exports.formatDeeplinkUrl = ze, exports.formatExpirerTarget = ae, exports.formatIdTarget = _n, exports.formatMessage = st, exports.formatMessageContext = wn, exports.formatRelayParams = wt, exports.formatRelayRpcUrl = Nn, exports.formatStatementFromRecap = me, exports.formatTopicTarget = jn, exports.formatUA = Be, exports.formatUri = jr, exports.fromBase64 = ue, exports.generateKeyPair = cr, exports.generateRandomBytes32 = ur, exports.getAccountsChains = j, exports.getAccountsFromNamespaces = ln, exports.getAddressFromAccount = je, exports.getAddressesFromAccounts = un, exports.getAppMetadata = En, exports.getBrowserOnlineStatus = Bt, exports.getBundleId = vn, exports.getChainFromAccount = _e, exports.getChainsFromAccounts = Ue, exports.getChainsFromNamespace = z, exports.getChainsFromNamespaces = dn, exports.getChainsFromRecap = sr, exports.getChainsFromRequiredNamespaces = pn, exports.getCommonValuesInArrays = ce, exports.getCryptoKeyFromKeyData = yt, exports.getDecodedRecapFromResources = it, exports.getDeepLink = Mn, exports.getDidAddress = de, exports.getDidAddressSegments = G, exports.getDidChainId = rt, exports.getEnvironment = C, exports.getHttpUrl = On, exports.getInternalError = S, exports.getJavascriptID = qe, exports.getJavascriptOS = Ke, exports.getLastItems = Je, exports.getLinkModeURL = _r, exports.getMethodsFromRecap = or, exports.getNamespacedDidChainId = ot, exports.getNamespacesChains = At, exports.getNamespacesEventsForChainId = Pt, exports.getNamespacesFromAccounts = $t, exports.getNamespacesMethodsForChainId = It, exports.getNodeOnlineStatus = Jt, exports.getReCapActions = ct, exports.getReactNativeOnlineStatus = Ht, exports.getRecapAbilitiesFromResource = tr, exports.getRecapFromResources = Z, exports.getRecapResource = at, exports.getRelayClientMetadata = bn, exports.getRelayProtocolApi = wr, exports.getRelayProtocolName = Sr, exports.getRequiredNamespacesFromNamespaces = Lr, exports.getSdkError = _, exports.getSearchParamFromURL = Fn, exports.getUniqueValues = oe, exports.handleDeeplinkRedirect = xn, exports.hasOverlap = w, exports.hashKey = dr, exports.hashMessage = pr, exports.isBrowser = M, exports.isCaipNamespace = Ne, exports.isConformingNamespaces = Kt, exports.isExpired = Vn, exports.isNode = ie, exports.isOnline = uo, exports.isProposalStruct = Jr, exports.isReactNative = D, exports.isRecap = fe, exports.isSessionCompatible = Br, exports.isSessionStruct = Wr, exports.isTelegram = Ye, exports.isTestRun = Kn, exports.isTypeOneEnvelope = vr, exports.isTypeTwoEnvelope = Er, exports.isUndefined = T, exports.isValidAccountId = Ut, exports.isValidAccounts = kt, exports.isValidActions = Mt, exports.isValidArray = K, exports.isValidChainId = q, exports.isValidChains = Dt, exports.isValidController = zr, exports.isValidEip1271Signature = Xe, exports.isValidEip191Signature = Ze, exports.isValidErrorReason = Xr, exports.isValidEvent = no, exports.isValidId = Qr, exports.isValidNamespaceAccounts = xt, exports.isValidNamespaceActions = we, exports.isValidNamespaceChains = Vt, exports.isValidNamespaceMethodsOrEvents = Se, exports.isValidNamespaces = Ft, exports.isValidNamespacesChainId = ro, exports.isValidNamespacesEvent = so, exports.isValidNamespacesRequest = oo, exports.isValidNumber = te, exports.isValidObject = ee, exports.isValidParams = Zr, exports.isValidRecap = N, exports.isValidRelay = Lt, exports.isValidRelays = Gr, exports.isValidRequest = eo, exports.isValidRequestExpiry = co, exports.isValidRequiredNamespaces = Yr, exports.isValidResponse = to, exports.isValidString = E, exports.isValidUrl = Hr, exports.mapEntries = An, exports.mapToObj = Rn, exports.mergeArrays = O, exports.mergeEncodedRecaps = rr, exports.mergeRecaps = ft, exports.normalizeNamespaces = Oe, exports.objToMap = Tn, exports.parseAccountId = re, exports.parseChainId = ne, exports.parseContextNames = He, exports.parseExpirerTarget = Un, exports.parseNamespaceKey = Ct, exports.parseRelayParams = Ot, exports.parseTopic = St, exports.parseUri = $r, exports.populateAuthPayload = Xn, exports.recapHasResource = er, exports.serialize = be, exports.subscribeToBrowserNetworkChange = Wt, exports.subscribeToNetworkChange = lo, exports.subscribeToReactNativeNetworkChange = zt, exports.toBase64 = Ge, exports.uuidv4 = Ln, exports.validateDecoding = yr, exports.validateEncoding = ht, exports.validateSignedCacao = Qn, exports.verifyP256Jwt = Or, exports.verifySignature = Qe;
 //# sourceMappingURL=index.cjs.js.map
diff --git a/package.json b/package.json
index b8af0f09781065988fb544b0f5504fadc6b71d25..c1328f8ded800730387ae17e079682786da22994 100644
--- a/package.json
+++ b/package.json
@@ -56,5 +56,35 @@
     "@types/elliptic": "6.4.18",
     "@types/lodash.isequal": "4.5.6",
     "@walletconnect/jsonrpc-types": "1.0.4"
+  },
+  "react-native": {
+    "zlib": "browserify-zlib",
+    "http": "@tradle/react-native-http",
+    "https": "https-browserify",
+    "os": "react-native-os",
+    "path": "path-browserify",
+    "fs": "react-native-level-fs",
+    "_stream_transform": "readable-stream/transform",
+    "_stream_readable": "readable-stream/readable",
+    "_stream_writable": "readable-stream/writable",
+    "_stream_duplex": "readable-stream/duplex",
+    "_stream_passthrough": "readable-stream/passthrough",
+    "stream": "stream-browserify",
+    "vm": "vm-browserify"
+  },
+  "browser": {
+    "zlib": "browserify-zlib",
+    "http": "@tradle/react-native-http",
+    "https": "https-browserify",
+    "os": "react-native-os",
+    "path": "path-browserify",
+    "fs": "react-native-level-fs",
+    "_stream_transform": "readable-stream/transform",
+    "_stream_readable": "readable-stream/readable",
+    "_stream_writable": "readable-stream/writable",
+    "_stream_duplex": "readable-stream/duplex",
+    "_stream_passthrough": "readable-stream/passthrough",
+    "stream": "stream-browserify",
+    "vm": "vm-browserify"
   }
 }
